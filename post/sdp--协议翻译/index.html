<!doctype html><html lang=en-us><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta property="og:site_name" content="ICJJ Blog"><meta property="og:type" content="article"><meta property="og:image" content="img/site/小米汽车/原型车壁纸/2880x1280/2880x1280-08.png"><meta property="twitter:image" content="img/site/小米汽车/原型车壁纸/2880x1280/2880x1280-08.png"><meta name=title content="SDP-协议翻译"><meta property="og:title" content="SDP-协议翻译"><meta property="twitter:title" content="SDP-协议翻译"><meta name=description content="程建军，数字IC设计验证工程师, 开源爱好者，生活探险家 | 这里是 程建军 的博客，与你一起发现更大的世界。"><meta property="og:description" content="程建军，数字IC设计验证工程师, 开源爱好者，生活探险家 | 这里是 程建军 的博客，与你一起发现更大的世界。"><meta property="twitter:description" content="程建军，数字IC设计验证工程师, 开源爱好者，生活探险家 | 这里是 程建军 的博客，与你一起发现更大的世界。"><meta property="twitter:card" content="summary"><meta name=keyword content="程建军, chengjianjun, ChengJianjun, , 程建军的网络日志, 程建军的博客, ChengJianjun Blog, 博客, 个人网站, AMBA, FPGA, SPINALHDL, PCIE"><link rel="shortcut icon" href=/icer/img/site/favicon.ico><title>SDP-协议翻译 | 程建军的博客 | ChengJianjun Blog</title>
<link rel=canonical href=/icer/post/sdp--%E5%8D%8F%E8%AE%AE%E7%BF%BB%E8%AF%91/><link rel=stylesheet href=/icer/css/bootstrap.min.css><link rel=stylesheet href=/icer/css/hugo-theme-cleanwhite.min.css><link rel=stylesheet href=/icer/css/zanshang.css><link rel=stylesheet href=/icer/css/font-awesome.all.min.css><script src=/icer/js/jquery.min.js></script><script src=/icer/js/bootstrap.min.js></script><script src=/icer/js/hux-blog.min.js></script><script src=/icer/js/lazysizes.min.js></script></head><script async src="https://www.googletagmanager.com/gtag/js?id=G-FWR2FVFK68"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-FWR2FVFK68")}</script><nav class="navbar navbar-default navbar-custom navbar-fixed-top"><div class=container-fluid><div class="navbar-header page-scroll"><button type=button class=navbar-toggle>
<span class=sr-only>Toggle navigation</span>
<span class=icon-bar></span>
<span class=icon-bar></span>
<span class=icon-bar></span>
</button>
<a class=navbar-brand href=/icer>ICJJ Blog</a></div><div id=huxblog_navbar><div class=navbar-collapse><ul class="nav navbar-nav navbar-right"><li><a href=/icer>Posts</a></li><li><a href=/icer/categories/bus/>bus</a></li><li><a href=/icer/categories/tech/>tech</a></li><li><a href=/icer/categories/tips/>tips</a></li><li><a href=/icer/archive/>ARCHIVE</a></li><li><a href=/icer/about/>ABOUT</a></li><li><a href=/icer/search><i class="fa fa-search"></i></a></li></ul></div></div></div></nav><script>var $body=document.body,$toggle=document.querySelector(".navbar-toggle"),$navbar=document.querySelector("#huxblog_navbar"),$collapse=document.querySelector(".navbar-collapse");$toggle.addEventListener("click",handleMagic);function handleMagic(){$navbar.className.indexOf("in")>0?($navbar.className=" ",setTimeout(function(){$navbar.className.indexOf("in")<0&&($collapse.style.height="0px")},400)):($collapse.style.height="auto",$navbar.className+=" in")}</script><style type=text/css>header.intro-header{background-image:url(/icer/img/site/%e5%b0%8f%e7%b1%b3%e6%b1%bd%e8%bd%a6/%e5%8e%9f%e5%9e%8b%e8%bd%a6%e5%a3%81%e7%ba%b8/2880x1280/2880x1280-08.png)}</style><header class=intro-header><div class=container><div class=row><div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1"><div class=post-heading><div class=tags><a class=tag href=/tags/sdp title=SDP>SDP</a></div><h1>SDP-协议翻译</h1><h2 class=subheading></h2><span class=meta>Posted by
程建军
on
Tuesday, April 23, 2024</span></div></div></div></div></header><article><div class=container><div class=row><div class="col-lg-8 col-lg-offset-2
col-md-10 col-md-offset-1
post-container"><h1 id=a-idsdp-协议翻译sdp-协议翻译a><a id="sdp 协议翻译">sdp 协议翻译</a></h1><blockquote><p><a href=https://icjj.github.io/icer/document/SOC-15_Specification_Scalable_Data_port_SDP_Rev_1.5.0,_Nov_10,_2022_1.pdf>SOC-15_Specification_Scalable_Data_port_(SDP)_Rev_1.5.0,_Nov_10,_2022_1.pdf</a></p></blockquote><h2 id=a-idsdp-协议翻译sdp-协议翻译a-1><a id="sdp 协议翻译">sdp 协议翻译</a></h2><h3 id=a-id第1章-介绍第1章-介绍a><a id="第1章 介绍">第1章 介绍</a></h3><p>部分介绍了SDP （Scalable Data Port）架构。
这个介绍_以下部分中呈现：</p><ul><li><em><a href="#1.1 概述">1.1 概述</a></em> 提供了架构的概述。</li><li><em><a href="#1.2 系统上下文">1.2 系统上下文</a></em> 为架构建立了系统上下文。</li></ul><h4 id=a-id11-概述11-概述a><a id="1.1 概述">1.1 概述</a></h4><p>SDP架构定义了一个逻辑信令interface和协议，设备可以通过该协议交换数据和控制信息，包括各种命令和响应消息。
SDP还定义了链路级和分离的请求/响应事务级协议。</p><p>端口是该架构定义的信令接口，它允许独立设计的逻辑块（IP块）通过结构化的方式直接或通过通信网络（fabric）进行通信。
端口的定义包括所需信号的枚举和信令方案在链路级别的管理。</p><p>链路级协议提供了：</p><ol><li>用于特定类型请求/响应消息和数据传输的多个物理通道。</li><li>于时钟速率匹配的简单同步接口，带有链路级握手信号。</li><li>号数量与物理通道带宽需求之间的平衡。</li><li>口请求/ack握手允许IP请求将接口激活到活动状态，或快速关闭时钟并节约功率。</li></ol><p>事务级协议提供以下功能和优点：</p><ol><li>分离请求/响应消息提高了fabric带宽的利用率。</li><li>每个事务标识tags支持在设备中为每个originator提供多个挂起的请求。</li><li>支持不需要originator生成探测响应的缓存一致内存读写操作。</li><li>支持一致和不一致的读写。</li><li>支持PCIe协议。</li><li>支持图形系统、x86和PCIe排序规则。</li><li>原子内存操作。</li><li>使用独立的基于credit的虚拟通道。</li><li>QOS服务质量提示。</li><li>事务安全特权级别。</li></ol><p>据通过请求/响应消息对进行传输。请求及其后续响应构成事务。</p><p>发起请求的设备称为“发起者”（originator）。
能够响应请求的设备称为“完成者”（completer）。
请求也称为命令。这些术语在本规范中可以互换使用。</p><p>端口定义了提供标准化附件方法的接口。
链路级协议定义了用于设备信息传输的信令模式，以及链路级传输握手协议。
由于扩展的数据端口专为芯片上应用设计，其中连接的IP块物理上靠近，因此接口相对宽泛，信令与SDP时钟同步。</p><p>当IP未直接点对点连接时，fabric 请求和响应消息在代理之间传递。
这样可以让IP块较少受到SOC时钟敏感性的影响，也不会受到SOC中的放置影响。
此外，IP块也可以与SoC专用时钟隔离，并解决测试确定性问题。
IP和SoC地面计划的物理实现选择将影响受此隔离影响的fabric的功率、面积和性能。</p><p>事务协议定义了可以由originator或通过fabric发出的请求，以及由fabric或completer发出的响应。
所有类型的请求都会返回给originator或fabric。响应通过fabric发送给originator，fabric作为completer的代理。
fabric内的消息流负责为所有缓存提供一致性控制。这允许包含缓存的IP块参与系统缓存一致性协议。</p><p>非一致协议是一致协议的子集，用于提高验证的便捷性。</p><p>SDP支持独立IP块设计和验证。链路级和事务级协议使得IP块能够将许多细节隔离，以处理一致和非一致数据的传输。
该架构为IP块之间的事务传输提供了清晰的分离。端口接口被清晰定义和标准化。
这允许端口接口逻辑由IP块自由使用。</p><h4 id=a-id12-系统上下文12-系统上下文a><a id="1.2 系统上下文">1.2 系统上下文</a></h4><p><a id="图 1">图 1</br><img src=https://icjj.github.io/icer/img/post/sdp/1.png alt></a></p><p>SDP架构（可扩展数据端口架构），它旨在提供一个丰富的功能集，以支持完全缓存一致性系统的实现，并通过接口将多个设备连接到共享系统内存。</p><p>为了更好地说明SDP的全部功能，该系统被描述为一个包含发起设备和响应设备的缓存一致性系统。
<em><a href="#图 1">图 1</a></em> 中的“可扩展数据端口系统上下文”显示了各种交换信息的设备类型，
以及它们使用该架构所定义的协议进行通信的方式。</p><p><em><a href="#图 1">图 1</a></em> 中展示的系统包含四种能够发起Transaction Request的设备（CPU Complex、GPU Complex、多媒体Complex
和PCI Host Bridge），以及三个可以成为请求目标的设备（PCI Host Bridge和两个系统内存区域）。
图中展示的PCI Host Bridge不仅可以发起请求，还能响应Transaction Request。内存设备通过单一端口连接到fabric（结构），
而第二个带地址切片的系统内存模块被包含在图中，表示内存可以通过多个端口连接到fabric，以提供更高的数据传输带宽。</p><p>该系统将发起事务的设备称为<strong>发起设备</strong>（Originator Devices），这些设备通过发起端口连接到fabric。
发起设备可以进一步细分为<strong>一致性发起设备</strong>（Coherent Originator）和<strong>非一致性发起设备</strong>（Non-Coherent Originator）。
一致性发起设备发布可被缓存一致性机制识别的缓存感知命令（如RdBlk或VIcBlkFull），
而非一致性发起设备虽然可以发出请求，但不参与缓存一致性协议。</p><p>专门响应请求的设备被称为<strong>完成设备</strong>（Completer Devices），这些设备通过完成端口连接到fabric。
系统内存模块和PCI Host Bridge的完成通道在图中以完成设备的形式出现。</p><p>架构并未明确规定fabric本身的拓扑结构，但基于假设，每个端口能够适当地满足请求，系统内存读取请求可以通过缓存中的数据副本来响应，
而不是直接从系统内存中获取数据。</p><p>连接到fabric的不同设备在系统中具有不同的角色，需要通过端口在fabric与设备之间传输不同类型的信息。
为了满足这一需求，SDP端口被定义为具有可选特性。特性提供特定的功能或能力。
当设备需要某个功能时，它必须实现为该特性定义的所有信号。例如，一些Originator不实现虚拟通道，
这些Originator不需要实现构成该特性的任何Field（如请求VC）。</p><p>SDP定义的所有特性都在 <em><a href=#TODO>TODO</a></em> 中进行了描述。</p><p>在 <em><a href="#图 1">图 1</a></em> 中，PCI主机桥的独特之处在于它既可以发起请求，又可以响应请求。
这样的设备通过一对端口连接到fabric，即一个Originator端口和一个Completer端口。</p><p>Originator通过发出读取或写入系统内存中目标位置的请求来启动一个事务。该请求通过Originator端口提交给fabric。
然后，fabric负责满足该请求，方法是访问内部缓存中的数据副本、在一致性域的某个缓存中找到请求的数据，
或读取或写入系统内存。作为该过程的一部分，fabric可能修改请求并生成自己的请求，以探测一致性域内的其他缓存。
fabric合并探测响应，并回复给Originator以完成事务。</p><p>该协议支持虚拟通道（VC），并允许Originator施加特定的VC内和VC间的顺序约束。</p><p>一个Originator可能包含多个功能unit。该协议通过为Originator内的每个请求者分配唯一的UnitID，支持每个功能unit的多个未完成请求。</p><p>允许事务乱序完成。事务tag使Originator能够将请求与后续的响应配对。读取和写入请求都需要响应。</p><p>每个设备都连接到fabric中的一个代理。
在 <em><a href="#图 1">图 1</a></em> 中，CM表示为一致性客户端（那些包含硬件一致性缓存的设备）代理的代理，
nCM表示为非一致性客户端（那些不包含缓存或仅包含软件一致性缓存的设备）代理的代理，CS表示为需要保持硬件一致性的内存代理，
而nCS代理不需要一致性的内存请求。nCM+nCS的一个特殊用途是作为一个组合的I/O代理，如 <em><a href="#图 1">图 1</a></em> 所示。
fabric合并来自一致性域中系统缓存的探测响应，并通过一致性Originator端口向连接的Originator呈现单一结果。</p><p>本规范未定义请求和响应消息在fabric上各端口之间路由的机制。
为在设备之间可靠且安全地传递这些消息而需要的任何请求和响应消息的翻译、编码和封装，都由fabric的更低层处理，并在其他文档中进行了说明。</p><p>SDP架构识别并支持为缓存一致性内存访问指定一致性域。
每个Transaction Request都包括必须探测的缓存域的规范，作为缓存一致性内存读取或写入请求的副作用。并非所有域都适用于每个请求。</p><p>本规范的其余部分按以下主题组织：</p><ul><li><em><a href="#第2章 端口定义">第2章 端口定义</a></em> ：描述端口接口的物理方面。</li><li><em><a href="#第3章 事务层">第3章 事务层</a></em> ：描述事务级别的协议。</li></ul><h3 id=a-id第2章-端口定义第2章-端口定义a><a id="第2章 端口定义">第2章 端口定义</a></h3><p>端口定义指定了通道内每个Field的名称和用途、链路级协议对信号状态变化时序施加的约束，以及在特定Field宽度方面给予实现的自由度。</p><p>以下章节描述了SDP物理接口：</p><ul><li><em><a href="#2.1 端口特性">2.1 端口特性</a></em> ：定义了端口定义的一些可选特性。</li><li><em><a href="#2.2 接口信号">2.2 接口信号</a></em> ：定义了构成SDP物理接口的Field。</li><li><em><a href="#2.3 端口参数化">2.3 端口参数化</a></em> ：定义了具有可变宽度的Field之间的依赖关系。</li><li><em><a href="#2.4 信号需求">2.4 信号需求</a></em> ：描述了对信号以及这些信号状态转换时序的约束。</li><li><em><a href="#2.5 端口控制">2.5 端口控制</a></em> ：描述了用于激活和断开接口的信令协议。</li></ul><p>SDP由八个物理通道组成，每个通道可以有多个实例。每个通道实例在特定方向上传输特定类型的信息。
例如，请求通道从Originator通过接口向系统传递Transaction Request。</p><p>Transaction Request、Originator数据，以及读和写响应通道支持最多八个虚拟通道（VC）。
虚拟通道构建在物理通道之上，提供请求消息传递保证（用于防止死锁）并支持所需的排序规则。
每个实现了flow control的通道都包含一个专用的credit释放通道，在相反方向上传递flow control信息。
对于支持多个VC的通道，flow control是按虚拟通道进行的。</p><h4 id=a-id21-端口特性21-端口特性a><a id="2.1 端口特性">2.1 端口特性</a></h4><p>SDP定义了以下特性：</p><p><strong>Asynchronous Port Control Feature（异步端口控制特性）</strong></p><p>当实现时，OrigClkReq、CompClkReq、OrigClkAck和CompClkAck与SdpClk是异步的。
这仅推荐用于对SDP端口在低时钟频率状态下重新连接延迟敏感的实现。</p><p><strong>Byte Enable Compression Feature（字节使能压缩特性）</strong></p><p>当实现时，Originator写/Probe数据通道实现一个单一的OrigDataBytEn，并改为在OrigData上携带字节使能。
参见 <em><a href="#3.2.1 字节使能压缩">3.2.1字节使能压缩</a></em> 。</p><p>支持Byte Enable Compression的实现可能不支持Metadata Compression。</p><p><strong>Cache Tag Tracking Feature（缓存Tag跟踪特性）</strong></p><p>当实现时，Originator在请求通道上提供缓存路和分配信息。
这使Completer能够使用“shadow tags”跟踪缓存的行以限制探测。
需要实现Probe Support Feature。需要ReqStWayId、ReqStUpdate和ReqStInvalidate。</p><p><strong>Credit Count Feature（credit计数特性）</strong></p><p>当实现时，允许端口一次返回多个credit。
需要实现
ReqCreditCnt、AckCreditCnt、RdRspCreditCnt、WrRspCreditCnt、PrbCreditCnt、PrbRspCreditCnt和OrigDataCreditCnt。
每个通道上credit计数的宽度和可用性是独立的。</p><p><strong>Completer Fatal Error Notification Feature（Completer致命错误通知特性）</strong></p><p>当实现时，允许Completer利用写响应通道（仅当未实现写响应通道时才使用读响应通道）以非请求（且无credit）的方式传递系统致命错误。</p><p><strong>Data Compression Feature（数据压缩特性）</strong></p><p>添加了四个新命令：
VicBlkFullZero、VicBlkFullComp、WrSizedFullZero、WrSizedFullComp，以及一种压缩数据的方法。</p><p><strong>Data Source Feature（数据源特性）</strong></p><p>当实现时，Completer利用RdRspSrcData和/或WrRspSrcData来传达数据或响应的来源。
这两个Field可以独立实现，不要求SDP同时具有RdRspSrcData和WrRspSrcData。</p><p><strong>Enhanced Port Control Feature（增强的端口控制特性）</strong></p><p>需要实现OrigClkCtl和CompClkCtl信号。
该特性允许代理在完全断开连接后请求重新初始化credit。该特性还允许代理为单边或全边断开连接发送提示。</p><p><strong>Enhanced RAS (V1, V2, V3) Feature（增强的RAS（版本1、2、3）特性）</strong></p><p>增强的RAS分为三个版本，允许在不同Field上独立的奇偶校验。这三个版本可以独立实现，且无先决条件。</p><ul><li><strong>增强的RAS V1特性</strong>：需要实现
ReqParity、ReqAddrParity、RdRspParity、WrRspParity、AckParity、PrbParity、PrbRspParity和OrigDataMetaParityField。</li><li><strong>增强的RAS V2特性</strong>：需要实现
RdRspDataStatusParityField。</li><li><strong>增强的RAS V3特性</strong>：需要实现
ReqCreditParity、RdRspCreditParity、WrRspCreditParity和OrigDataCreditParityField。</li></ul><p><strong>External Last Layer Cache Support（外部最后一层缓存支持）</strong></p><p>需要：ReqCacheHint（以前称为ReqNoAlloc）。</p><p><strong>Floating Point Atomic Feature（浮点原子操作特性）</strong></p><p>增强了Atomic*命令，包含了用于浮点原子操作的额外ReqAttr编码。</p><p><strong>Heads-up Feature（预通知特性）</strong></p><p>需要实现RdRspDataVld。没有该特性，N<sub>lag</sub>必须为零。</p><p><strong>I/O Stream Feature（I/O流特性）</strong></p><p>需要：ReqStreamID。还必须实现ReqBlockLevel = 01b（Stream）。</p><p><strong>I/O Space Feature（I/O空间特性）</strong></p><p>需要：ReqIOField。</p><p><strong>Low-Power Signaling Feature（低功耗信令特性）</strong></p><p>需要实现*ClkEn_m1，用于使能时钟。在某些实现中，时钟使能可能通过OR逻辑组合在一起。</p><p><strong>Metadata Compression Feature（元数据压缩特性）</strong></p><p>需要实现ReqCompMode、ReqSpecDataFetch、RdRspDataCompMeta以及某些请求的额外属性编码。
对于压缩写入，OrigDataBytEn的使用也会发生变化。
参见 <em><a href="#3.2.2 元数据压缩">3.2.2 元数据压缩</a></em> 。</p><p>支持Metadata Compression的实现可能不支持Byte Enable Compression。</p><p><strong>Multiple Request Address Feature（多请求地址特性）</strong></p><p>添加了ReqSubAddrField，指定了一些（但不是全部）地址位，
以便Originator可以将两个不同的地址组合成一个请求。</p><p><strong>Multiple Cache Line Feature（多缓存行特性）</strong></p><p>当实现时，Originator可以为多个缓存行（或单个缓存行）发出缓存读取命令，如ReqLen中指定。
实现可能会限制地址对齐和请求的缓存行数量。此特性不适用于缓存更新和缓存驱逐命令。</p><p>当未实现此特性时，所有缓存读取命令必须针对单个缓存行发出。</p><p><strong>Ordered Cacheable Command（有序可缓存命令）</strong></p><p>当实现时，Originator将所有块读取命令限制为仅RdBlkS，
并要求Completer对该可缓存命令和先前的WrSized*命令实现读后写排序。</p><p><strong>Physical Channel Multiplexing Feature（物理通道复用特性）</strong></p><p>需要实现ReqChanAB、ReqCreditChanAB、OrigDataChanAB和OrigDataCreditChanAB信号。</p><p><strong>Posted Write Ordering Feature（posted写入排序特性）</strong></p><p>需要实现ReqPassPW、ReqRspPassPW、RdRspPassPW、WrRspPassPW。</p><p><strong>Probe Chain Feature（探测链特性）</strong></p><p>需要实现rbChainField和Probe Support Feature的实现。</p><p><strong>Probe Compression Feature（探测压缩特性）</strong></p><p>需要实现rbCompType和PrbCompIndex，以及Probe Support Feature的实现。</p><p><strong>Probe Interrupt Delivery Feature（探测中断传递特性）</strong></p><p>该特性有两个版本。版本1添加了探测地址，可用于将向量中断传递给处理器线程。
版本2移除了第一组探测地址，添加了新地址，可用于将任何类型的向量和非向量中断传递给处理器线程。
版本2还增强了中断区域，允许处理器传递LVT，并添加了一个服务中区域，允许处理器确认先前传递的中断向量。
需要实现Probe Support Feature。</p><p><strong>Probe Support Feature（探测支持特性）</strong></p><p>需要实现探测请求和探测响应通道。
需要在Originator（写入/探测）数据通道上实现OrigDataChan和OrigDataPrbCreditRel。</p><p><strong>Read Response Feature（读响应特性）</strong></p><p>用于发出在读响应通道中响应的命令的Originator。需要实现读响应通道。仅当“只写”端口时才省略此特性。</p><p><strong>Response Acknowledge Feature（响应确认特性）</strong></p><p>需要实现响应确认通道的所有Field和ReqAckField。</p><p><strong>Secure Transaction Feature（安全事务特性）</strong></p><p>需要实现ReqSecLevel。</p><p><strong>Trusted Memory Feature（可信内存特性）</strong></p><p>需要实现ReqTMZ以及安全事务特性。</p><p><strong>Variable Heads-up Feature（可变预通知特性）</strong></p><p>需要RdRspDelayField。需要预通知特性作为先决条件。</p><p><strong>Virtual Address Feature（虚拟地址特性）</strong></p><p>需要实现ReqVirtAddr、ReqVfidValid、ReqVfid。</p><p><strong>Virtual Channel Support Feature（虚拟通道支持特性）</strong></p><p>需要实现
ReqVC、ReqCreditVC、ReqCreditType、RdRspVC、RdRspCreditType、RdRspCreditVC、
WrRspVC、WrRspCreditVC、WrRspCreditType、OrigDataVC、OrigDataCreditType、OrigDataCreditVC。</p><p><strong>Write Response Feature（写响应特性）</strong></p><p>用于发出在写响应通道中响应的命令的Originator。需要实现写响应通道。仅当“只读”端口时才省略此特性。</p><h4 id=a-id22-接口信号22-接口信号a><a id="2.2 接口信号">2.2 接口信号</a></h4><p><a id="图 2">图 2</br><img src=https://icjj.github.io/icer/img/post/sdp/2.png alt></a></p><p>本节描述了构成SDP接口的信号。</p><h5 id=a-id221-信号组221-信号组a><a id="2.2.1 信号组">2.2.1 信号组</a></h5><p>SDP接口被组织为以下组：</p><ul><li>Port Control信号</li><li>Command / Request通道</li><li>Data通道</li></ul><p>在 <em><a href="#图 2">图 2</a></em> 中，标有“Originator”的模块代表发出命令（请求）的代理，
“Completer”代表满足这些请求的代理。在典型的应用中，Originator并不直接连接到Completer，而是通过fabric间接连接。
在Originator端口，fabric作为Completer的代理；在Completer端口，fabric作为Originator的代理。</p><p>如 <em><a href="#图 2">图 2</a></em> 所示，物理通道可以组织为三组：
端口控制信号、命令/响应通道和数据通道。
共享名称并编码特定信息的一组信号称为Field。Field的大小属性表示构成该Field的信号数量。
Field内的信号根据二进制重要性编号。一个n位的Field由n-1到0的信号组成。</p><p><em><a href="#图 2">图 2</a></em> 为每个模块显示了一个独立的时钟。
这些时钟信号由SOC逻辑提供。如果这些时钟在频率上不匹配且没有静态相位关系，则必须提供重新同步逻辑。同步逻辑已被考虑，但未具体规定。</p><p>注意，读响应和读响应数据通道共享相同的链路级握手信号，并在 <em><a href="#Read Response Channel">Read Response Channel</a></em> 中一起描述。</p><p><a id=端口控制>端口控制</a></p><p>每个端口包括两对端口控制信号。
这些信号允许连接的设备请求将端口提升到活动状态，或置于静止状态，以便设备过渡到时钟停止或电源门控状态。
端口控制状态转换也可以由端口发起。这些信号在 <em><a href="#2.2.4 Read Response Channel">2.2.4 端口控制信号</a></em> 中进行了描述。</p><p><strong>命令/响应通道</strong></p><p>命令和响应通道包含用于请求或确认数据和/或控制信息传输的Field。这些通道包括：</p><ul><li><em><a href="#2.2.6 originator request channel">2.2.6 Originator Request Channel</a></em></li><li><em><a href="#2.2.7 read response channel">2.2.7 Read Response Channel</a></em></li><li><em><a href="#2.2.8 write response channel">2.2.8 Write Response Channel</a></em></li><li><em><a href="#2.2.9 response acknowledge channel">2.2.9 Response Acknowledge Channel</a></em></li><li><em><a href="#2.2.10 probe request channel">2.2.10 Probe Request Channel</a></em></li><li><em><a href="#2.2.11 probe response channel">2.2.11 Probe Response Channel</a></em></li></ul><p><a id="Data Channels">Data Channels</a></p><p>数据通道用于在系统中从Originator到Completer或从Completer到Originator传输数据。这些通道包括：</p><ul><li><em><a href="#Originator (Write/Probe) Data Channel">Originator (Write/Probe) Data Channel</a></em></li><li><em><a href="#Read Response Channel">Read Response Channel</a></em></li></ul><p><strong>其他信号</strong></p><p>每个端口接口都包括一个由SOC逻辑提供的时钟和复位信号。这些内容在 <em><a href="#2.2.3 通用信号">2.2.3 通用信号</a></em> 中进行了描述。</p><p>端口接口上的所有信号都与公共时钟同步。
信号从接口一侧的寄存器发出，预期在接收端用于在接收寄存器中锁存信息的时钟边沿之前，
能够到达另一侧并有足够的时间被用于少量逻辑（可能导致Vld/Rdy的去使能，或将发送队列推进到下一个项目）。
在实际实现中，接口一侧提供一组信号的寄存器可能与接收信号的一侧处于不同的时钟域。
本规范未指定的一种机制会跟踪独立时钟之间的任何相位偏移并进行补偿。</p><p><strong>端口信号</strong></p><p>请参见 <em><a href="#图 3">图 3</a></em> 。
请注意，一个Originator设备通过称为Originator端口的接口连接到fabric，
一个Completer设备通过称为Completer端口的接口连接到fabric。
Completer端口是Originator端口的子集，因为Completer不需要与Originator相同的功能。</p><p><a id="图 3">图 3</br><img src=https://icjj.github.io/icer/img/post/sdp/3.png alt></a></p><p>在Originator端口，Originator设备（或简称为Originator）驱动请求信号，而Originator端口接收请求信号。
Fabric要么直接满足请求，要么将请求路由到适当的Completer端口，在那里请求被呈现给Completer设备。</p><p>在Completer端口，端口发出请求信号，Completer设备接收这些信号。
Completer设备处理请求并生成响应。设备发出响应信号，端口接收它们。
由fabric路由回Originator的响应出现在Originator端口的响应物理通道上。
在Originator端口，端口发出响应信号，Originator接收这些信号。</p><p>在之后的小节中，表格列出了属于SDP接口每个通道的Field。
在这些表中，指定了originator端口中每个Field的驱动者。
因此，指定的驱动者要么是originator，要么是端口。
在completer端口，如果Field被实现，信息流向右的Field将由端口驱动，信息流向左的Field将由completer设备驱动。</p><p>可选Field根据它们支持的特性进行标识。未实现的可选Field的默认值为0，除非另有说明。</p><p>当originator和completer以点对点连接时，fabric消失，originator对completer设备看起来像一个completer端口。
反过来，completer看起来像一个originator端口。</p><h5 id=a-id222-在单个通道内增加带宽的方法222-在单个通道内增加带宽的方法a><a id="2.2.2 在单个通道内增加带宽的方法">2.2.2 在单个通道内增加带宽的方法</a></h5><p>有多种方法可以利用单个端口来增加带宽。本节描述了这些方法并区分了它们的预期用例。请注意，这些方法是可互操作的，且一个SDP实现可能具有多个。</p><p><strong>实现多个通道实例</strong></p><p>一个实现可能提供单个通道类型的多个实例。例如，一个实现可能有两个originator请求通道和三个读响应通道。
当引用这些通道和通道中的所有Field时，它们分别标记为“A”、“B”、“C”等，例如可能有一个“Request Channel A”，具有FieldReqAVld、ReqAVc（等等），
然后可能有一个“Request Channel B”，具有FieldReqBVld、ReqBVc（等等），依此类推，直到实现的数量（A-Z）。
当给定类型只有一个通道时，“A”是多余的，可以省略。在本规范中，Field名称始终被使用，好像只有一个通道，为了简单起见，省略了“A”。
没有要求端口对每种通道类型具有相同数量的实例。</p><p>在本规范中，当提及所有实例化的通道整体时，通道名首字母大写（“Originator Request Channel”），
例如指代credit或Tag，假定讨论的主题可能发生在任何实例化的通道上。
当指代单个实例时，通道名不大写（“originator request channel”或“originator request channel A”），
例如指代在originator request channel的某个实例上出现的请求。</p><p>给定通道的所有实例共享credits、Tags和UnitID编码。
在不同通道类型的实例之间没有必需的关联关系。
例如，在“originator request channel A”上的请求可能使用最初在“originator request channel B”上（从completer）传输的credit。
此外，该请求的响应然后可能由completer在“read response channel C”上传输。</p><p>给定通道的多个实例在所有排序目的上使用它们的字母编号被视为“时分复用”的。
也就是说，在“originator request channel B”上某个周期出现的请求被认为比同一周期在“originator request channel A”上（如果有有效请求）传输的任何请求更晚传输，
并被认为比在“originator request channels C”到最后一个originator request channel实例上（如果有有效请求）传输的任何请求更早传输。
如果两个请求之间没有必需的排序，例如它们在不同的VC中，那么这种时分复用关系就无关紧要。</p><p>通道类型的所有Field在每个实例中都被复制，包括*ClkEn_m1、*Vld和*Rdy信号。
为了确保维护时分复用的排序关系，任何端口延迟或时钟交叉实现必须在所有实例之间相同。
如果originator request channel A的ReqRdy信号在一个周期内未激活，而originator request channel B的ReqRdy信号在该周期内激活，
那么时分复用的排序要求可能被违反。因此，*Rdy信号，虽然独立实例化并可能独立生成，必须最终彼此完全相同，无论最初是否有必需的排序关系。</p><p>每个通道实例都有独立的*ClkEn_m1实例，允许端口独立地对一个或多个实例进行时钟门控。
没有要求较高命名的端口在较低命名的端口之前或之后被时钟门控。
例如，“originator request channel A”可能被时钟门控，而“originator request channel B”可能正在传输请求。
当一个实例在周期x上取消置位<em>ClkEn_m1时，假定端口的另一侧可能在周期x+1将该通道实例视为</em>Vld=0，这在每个实例上独立发生。</p><p>无论实现了多少通道以及每种通道类型的实例数量，对于单个端口只有一组端口控制信号。</p><p>多个通道实例的预期目的是在较低的时钟速率下支持更高的带宽。
具有两个实例的端口可以被认为其操作就像SDPClk的频率是原来的两倍，一个实例在偶数时钟周期传输第一个通道实例，第二个实例在奇数时钟周期传输。</p><p><strong>物理通道复用特性</strong></p><p>物理通道复用特性允许两个独立的completer实体共享单个SDP用于所有数据传输，
尽管该特性（在规范的未来版本中）可能允许独立的originator实体和/或将数量扩展到两个以上。
要求originator知道两个completer实体，并为每一个跟踪单独的credits。
例如，在ReqCreditChanAB=0（子通道A）上返回的credit只能用于断言ReqChanAB=0的请求。
originator必须有一种方法在两个子通道之间进行选择，例如通过对请求地址进行哈希。实际方法超出了本规范的范围。</p><p>物理通道多路复用特性的预期目的是两个completer总是与单个originator通信时共享线路（SDP端口），例如逻辑上是单个内存通道的两个子通道。</p><h5 id=a-id223-通用信号223-通用信号a><a id="2.2.3 通用信号">2.2.3 通用信号</a></h5><p><em><a href="#表 2 通用信号">表 2 通用信号</a></em> 列出了通用信号组的信号。</p><p><a id="表 2 通用信号">表 2 通用信号</a></p><table><thead><tr><th>信号名</th><th>位宽</th><th>驱动</th><th>描述</th></tr></thead><tbody><tr><td>SdpClk</td><td>1</td><td>SOC逻辑</td><td>接口时钟，由SOC逻辑提供。</br>SDP端口信号与此时钟同步，以下情况除外：</br>- <strong>SdpReset_N</strong>的置位。</br>- <strong>*ClkCtl</strong>，属于增强端口控制特性的一部分，与 <strong>*ClkReq</strong>同步。</br>- <strong>*ClkReq</strong>和 <strong>*ClkAck</strong>，在实现了异步端口控制特性情况下。</br>当未实现异步端口控制特性时，这四个信号与<strong>SdpClk</strong>同步。</td></tr><tr><td>SdpReset_N</td><td>1</td><td>SOC逻辑</td><td><strong>接口复位信号</strong>，低电平有效。Reset可以异步于SdpClk置位，但取消置位是同步于SdpClk的。</td></tr></tbody></table><p>SdpClk的上升沿决定了接口上传输信息的时序。
一般来说，所有信号在SdpClk的上升沿之前和紧接之后都必须保持稳定。
实际上，端口接口两侧的寄存器可能位于不同的时钟域中。
*Rdy用于确保发射器的时钟有效边沿相对于接收器的有效边沿之间有足够的时间。</p><p>SdpReset_N是一个负有效信号（即，当信号的电压水平为低时，信号被置位），并且可以在任何时间被置位。
有关与SdpReset_相关的信令要求的更多信息，请参见 <em><a href="#2.4 信号需求">2.4 信号需求</a></em>。</p><h5 id=a-id224-端口控制信号224-端口控制信号a><a id="2.2.4 端口控制信号">2.2.4 端口控制信号</a></h5><p>每个端口提供了两对请求/确认信号，允许Originator或Completer请求将端口提升到其正常的活动状态，
或者，一旦端口处于正常的活动状态，请求将端口降级并逻辑上断开连接。
在断开连接的状态下，接口之间没有信息交换。所有*Vld信号都是非活动的，所有物理通道Field都被忽略。
这允许一个或两个代理进入低功耗的时钟停止或电源门控状态。增强的端口控制特性增加了第三对信号，用于提供关于连接或断开请求的更多信息。</p><p>表3 <strong>端口控制信号</strong>列出了端口控制信号。</p><p>标有“Required”（必需）的列指示了哪个可选特性需要实现此Field。“Yes”表示所有实现都需要该特性。标有“Driver”（驱动者）的列指示了在Originator端口上信号的方向。</p><p><a id="表 3 端口控制信号">表 3 端口控制信号</a></p><table><thead><tr><th>信号名</th><th>位宽</th><th>驱动</th><th>描述</th><th>需求</th></tr></thead><tbody><tr><td><em><a href=#origclkreq>OrigClkReq</a></em></td><td>1</td><td>Originator</td><td>Originator时钟请求。</br>由Originator置位，以请求将端口提升到活动状态。当实现了异步端口控制特性时，该信号与SdpClk异步。</td><td>Yes</td></tr><tr><td><em><a href=#compclkack>CompClkAck</a></em></td><td>1</td><td>Port</td><td>Completer时钟确认。<br>由Completer在响应OrigClkReq信号时置位。当实现了异步端口控制特性时，该信号与SdpClk异步。</td><td>Yes</td></tr><tr><td><em><a href=#compclkreq>CompClkReq</a></em></td><td>1</td><td>Port</td><td>Completer时钟请求。<br>由Completer置位，以请求将端口提升到活动状态。当实现了异步端口控制特性时，该信号与SdpClk异步。</td><td>Yes</td></tr><tr><td><em><a href=#origclkack>OrigClkAck</a></em></td><td>1</td><td>Originator</td><td>Originator时钟确认。<br>由Originator在响应CompClkReq信号时置位。当实现了异步端口控制特性时，该信号与SdpClk异步。</td><td>Yes</td></tr><tr><td><em><a href=#origclkctl>OrigClkCtl</a></em></td><td>1</td><td>Originator</td><td>Originator时钟控制。<br>在置位或取消置位OrigClkReq之前，由Originator设置为活动或非活动电平，以指示关于连接或断开请求的附加信息。该信号与SdpClk异步，并且仅在OrigClkReq的边沿采样。</td><td>Enhanced port control feature</td></tr><tr><td><em><a href=#compclkctl>CompClkCtl</a></em></td><td>1</td><td>Port</td><td>Completer时钟控制。<br>在置位或取消置位CompClkReq之前，由Completer设置为活动或非活动电平，以指示关于连接或断开请求的附加信息。该信号与SdpClk异步，并且仅在CompClkReq的边沿采样。</td><td>Enhanced port control feature</td></tr></tbody></table><p>SDP接口由多个单向物理通道组成。
例如，一个一致性的Originator在Originator Request、Originator (Write/Probe) Data、Response Acknowledge和Probe Response Channels上担任发送者的角色。
在Read Response（包括读取数据）、Write Response和Probe Request Channels上，它担任接收者的角色。
作为Completer代理的端口在每个通道上具有互补的角色。</p><p>虽然接口由多个物理通道组成，但为Originator（或在Completer端口上的端口）提供了一个单一的信号，
用于请求接口的激活（OrigClkReq），以及为端口（或Completer）提供了一个单一的信号来发出此请求（CompClkReq）。
信号CompClkAck（由接口的Completer侧驱动）和OrigClkAck（由Originator侧驱动）用于完成将端口带入其活动操作模式所需的握手协议。
在初始化协议完成时，所有四个信号都处于其活动状态。这表明接口处于正常的活动状态。</p><p><strong><a id=origclkreq>OrigClkReq</a></strong></p><p>Originator（或在Completer端口上的port）置位OrigClkReq以请求将端口接口提升到活动状态。
该信号在端口处于其正常活动操作模式时必须保持激活。
当通过置位CompClkAck得到确认时，端口（或在Completer端口上的Completer）已准备好在其所有入站通道上接收信息。
Originator（或在Completer端口上的port）取消置位该信号以请求断开端口。
断开请求由端口（或在Completer端口上的Completer）通过取消置位CompClkAck信号来确认。</p><p><strong><a id=compclkack>CompClkAck</a></strong></p><p>由port（或在completer端口上的completer）置位，以响应OrigClkReq，指示port（completer）已准备好在相应的物理通道上主动接收入站的命令、数据或流控制credit。</p><p><strong><a id=compclkreq>CompClkReq</a></strong></p><p>port（或在completer端口上的completer）置位CompClkReq，以请求将端口接口提升到活动状态。
在端口处于其正常活动操作模式时，该信号必须保持激活。
当收到OrigClkAck的置位确认时，port（或在originator端口上的originator）已准备好在其所有入站通道上接收信息。
port（或在completer端口上的completer）取消置位该信号以请求断开端口。
断开请求由originator（或在completer端口上的port）通过取消置位OrigClkAck信号来确认。</p><p><strong><a id=origclkack>OrigClkAck</a></strong></p><p>由originator（或在completer端口上的port）置位，以响应CompClkReq，指示completer已准备好在相应的物理通道上主动接收入站的命令、数据或流控制credit。</p><p><strong><a id=origclkctl>OrigClkCtl</a></strong></p><p>当检测到OrigClkReq信号的转换时，port（或在completer端口上的completer）可以对该信号进行采样。
originator（或在completer端口上的port）在置位OrigClkReq之前置位此信号，
以请求port（completer）为originator（port）的使用流控制的出站通道发出（或重新发出）流控制credit。
originator在置位OrigClkReq之前取消置位此信号，以明确请求completer不发出这些credit。
在连接请求得到port（或在completer端口上的completer）的确认之前，该信号的状态必须保持稳定。</p><p>如果originator（或在completer端口上的port）请求完全断开连接，则在取消置位OrigClkReq之前置位此信号。
如果请求临时（单向）断开连接，则在取消置位OrigClkReq之前取消置位此信号。
在断开请求得到port（或在completer端口上的completer）的确认之前，该信号的状态必须保持稳定。</p><p>一些SDP端口实现可能通过固件或复位序列等替代方式处理流控制credit，并且可能仅使用OrigClkReq来指示完全断开连接。</p><p><strong><a id=compclkctl>CompClkCtl</a></strong></p><p>当检测到CompClkReq信号的转换时，originator（或在completer端口上的port）可以对该信号进行采样。
port（或在completer端口上的completer）在置位CompClkReq之前置位此信号，
以请求originator（或在completer端口上的port）为port（completer）的使用流控制的出站通道发出（或重新发出）流控制credit。
port在置位CompClkReq之前取消置位此信号，以明确请求originator（port）不发出这些credit。</p><p>如果port（或在completer端口上的completer）请求完全断开连接，则在取消置位CompClkReq之前置位此信号。
如果请求临时（单向）断开连接，则在取消置位CompClkReq之前取消置位此信号。
在断开请求得到originator（或在completer端口上的port）的确认之前，该信号的状态必须保持稳定。</p><p>一些SDP端口实现可能通过固件或复位序列等替代方式处理流控制credit，并且可能仅使用CompClkReq来指示完全断开连接。</p><p>关于连接和断开端口的协议细节在 <em><a href=#端口控制>端口控制</a></em> 中讨论。</p><p><strong>端口控制信号的同步要求</strong></p><p>当端口实现异步端口控制特性时，OrigClkReq、CompClkReq、OrigClkAck和CompClkAck的置位和取消置位可能与SdpClk异步。
接收逻辑有责任在IP时钟域内使用一个或多个锁存器或其他方法对信号进行采样，以防止亚稳态。
当只有端口的一侧实现了异步端口控制特性时，端口之间需要广泛逻辑，以在异步到同步方向上同步信号。</p><h5 id=a-id225-通道之间的关系225-通道之间的关系a><a id="2.2.5 通道之间的关系">2.2.5 通道之间的关系</a></h5><p>作为本规范其他部分的总结，本规范对通道类型之间要求以下关系：</p><ul><li><p>除了Cancel、QosControl和ErrEvent请求包，以及SYSFATALERR响应外，代理不得在没有由其他代理发出足够credit的情况下，发出请求、探测、响应或数据包。
不消耗credit的命令或响应例外。</p></li><li><p>对于一个请求，在它已经在Request Channel上发出了对应的请求之前，不得在originator数据通道上发送该请求的数据。
数据只能在与请求同时的周期或更晚的周期发送。</p></li><li><p>对于一个探测响应的数据，在originator探测数据通道上，originator必须在已在探测响应通道上发出对应的探测响应之后，才能发送数据。
数据只能在与探测响应同时的周期或更晚的周期出现。</p></li><li><p>除了针对SYSFATALERR的“非请求”响应外，completer不得在接收到Request Channel上的请求（由ReqTag和ReqUnitID匹配）之前提供响应。
此外，当请求包含数据时，completer不得在接收到Originator Data Channel上所有数据节拍之前，为该请求发出响应。
特定请求无关的“非请求”响应例外。</p></li><li><p>在完成端口控制握手之前，代理不得在任何通道上传输任何信息，包括credits或请求/响应/探测/数据包。</p></li></ul><p>本规范还要求以下通道之间的死锁避免要求：</p><ul><li><p>Originator必须能够处理探测请求，返回适当的credit，并提供响应和数据（如果有），而无需completer对未完成的请求提供读或写响应的任何要求。</p></li><li><p>Originator必须能够处理探测请求，返回适当的credit，并提供响应和数据（如果有），而无需completer提供请求通道credits或断言ReqRdy的任何要求。</p></li><li><p>实现Response Acknowledge Feature的originator必须能够在completer已经发出完成后，发出响应确认，
而不需要除在Response Acknowledge Channel上拥有credit之外的任何依赖。</p></li><li><p>一旦originator发出了请求，它必须能够处理（或“接收”）响应，包括返回读或写响应credit，而无需completer处理任何其他命令的任何要求，
包括但不限于其他victims或写入。该要求也可以表述为：在发出可能在读响应通道上提供数据的命令时，originator必须有一个缓冲区来消耗读取的数据，
而不依赖于completer处理其他请求，包括victims或写入。只要originator有一种无依赖的方法来接收读响应，则此缓冲区不必在请求时被宣告为读响应credit。</p></li></ul><h5 id=a-id226-originator-request-channel226-originator-request-channela><a id="2.2.6 originator request channel">2.2.6 originator request channel</a></h5><p>Originator使用Originator请求通道来请求将数据写入或从系统内存空间读取数据。
<em><a href="#表 4 Originator请求通道信号">表 4 Originator请求通道信号</a></em> 列出了构成Originator请求通道的信号。</p><p>标记为<strong>Required</strong>的列指示了哪个可选特性要求实现该Field。“Yes”表示所有实现都需要该特性。</p><p>标记为<strong>Driver</strong>的列指示了在Originator端口中Field内的信息流方向。</p><p><strong><a id="表 4 Originator请求通道信号">表 4 Originator请求通道信号</a></strong></p><table><thead><tr><th>Name</th><th>Size</th><th>Driver</th><th>Description</th><th>Required</th></tr></thead><tbody><tr><td><em><a href=#reqtag>ReqTag</a></em></td><td>N<sub>rt</sub></td><td>Originator</td><td>Request Tag。<br>该Field用于唯一标识通过此端口连接的Originatorunit的每个未完成请求。有关更多信息，请参见下文的 <em><a href=#reqtag>reqtag</a></em> 。</td><td>Yes</td></tr><tr><td><em><a href=#reqaddr>ReqAddr</a></em></td><td>N<sub>ra</sub></td><td>Originator</td><td>Request地址。<br>对于缓存读取，此Field指示请求对齐缓存块的关键字节。<br>对于其他命令，此Field给出了在标记为DataOffset 0（最低地址的数据字节）的节中要传输的数据的字节地址。有关更多信息，请参见下文的 <em><a href=#reqaddr>reqaddr</a></em> 。</td><td>Yes</td></tr><tr><td><em><a href=#reqsubaddr>ReqSubAddr</a></em></td><td>N<sub>rsa</sub></td><td>Originator</td><td>Request子地址。<br>对于非缓存访问，此Field指示对地址位的一个子集执行的异或操作，以创建两个逻辑上独立的事务，这些事务在SDP上组合为一个事务。<br>此Field的使用可能受限。有关更多信息，请参见下文的 <em><a href=#reqsubaddr>reqsubaddr</a></em> 。<br>作为一个异或，当此Field为零时；ReqAddr包含整个请求事务的地址。</td><td>Multiple Request Address feature</td></tr><tr><td><em><a href=#reqspecialaddr>ReqSpecialAddr</a></em></td><td>1</td><td>Originator</td><td>系统管理请求。<br>此Field指示地址空间信息。有关更多信息，请参见下文的 <em><a href=#reqapecialaddr>reqapecialaddr</a></em> 和 <em><a href=#reqio>reqio</a></em> 。<br>如果未实现，Completer根据ReqIO和系统地址映射来解释地址。</td><td>System Management Access feature</td></tr><tr><td><em><a href=#reqio>ReqIO</a></em></td><td>1</td><td>Originator</td><td>Request I/O。<br>此Field指示地址空间信息。有关更多信息，请参见下文的 <em><a href=#sysmgmt>sysmgmt</a></em> 和 <em><a href=#reqio>reqio</a></em> 。<br>如果未实现，Completer根据系统地址映射来解释地址。</td><td>I/O space feature</td></tr><tr><td><em><a href=#reqlen>ReqLen</a></em></td><td>N<sub>rl</sub></td><td>Originator</td><td>Request长度。<br>此Field指示事务请求要传输的数据量。请求的传输大小为(ReqLen + 1)个双字。<br>有关更多信息，请参见下文的 <em><a href=#reqlen>reqlen</a></em> 。</td><td>Yes</td></tr><tr><td><em><a href=#reqack>ReqAck</a></em></td><td>1</td><td>Originator</td><td>当设置为0时，表示在收到对此请求的响应时，不会在Response Acknowledge通道上发送事务响应确认。<br>对于任何需要响应确认的命令，必须将此位设置为1。<br>如果未实现，所有请求都必须被视为此Field设置为0。</td><td>Response Acknowledge feature</td></tr><tr><td><em><a href=#reqattr>ReqAttr</a></em></td><td>8</td><td>Originator</td><td>Request属性。<br>用于目标的扩展事务属性。此Field的编码取决于请求。<br>有关此Field的特定编码，请参见下文的 <em><a href=#reqattr>reqattr</a></em> 。<br>对于不生成带有扩展属性请求的Originator，ReqAttr不是必需的。</td><td></td></tr><tr><td><em><a href=#reqqospriority>ReqQosPriority</a></em></td><td>N<sub>pri</sub></td><td>Originator</td><td>服务质量优先级。<br>0是最低优先级，(2^Npri – 1)是最高优先级。</td><td>QoS feature</td></tr><tr><td><em><a href=#reqqosforward>ReqQosForward</a></em></td><td>2</td><td>Originator</td><td>服务质量转发。<br>指示哪些先前的请求（如果有）应以ReqQosPriority处理。有关此Field的特定编码，请参见ReqQosForward。<br>QoS特性的实现可以不实例化此Field，端口将其视为Field始终为00b。</td><td>QoS feature</td></tr><tr><td><em><a href=#reqcmd>ReqCmd</a></em></td><td>6</td><td>Originator</td><td>Request命令。<br>此Field指示此请求的事务类型。<br>有关此Field的编码，请参见 <em><a href="#3.6 命令">3.6 命令</a></em> 。</td><td>Yes</td></tr><tr><td><em><a href=#reqdomain>ReqDomain</a></em></td><td>1</td><td>Originator</td><td>Request域。<br>此信号指示请求事务的可共享域。</td><td>在实现可共享域的系统中是必需的。</td></tr><tr><td><em><a href=#reqvirtaddr>ReqVirtAddr</a></em></td><td>1</td><td>Originator</td><td>Request虚拟地址。<br>此信号指示ReqAddr是必须翻译的虚拟地址。</td><td>Virtual Address Feature</td></tr><tr><td><em><a href=#reqvfidvalid>ReqVfidValid</a></em></td><td>1</td><td>Originator</td><td>Request虚拟功能ID有效。<br>此信号指示ReqVfidField中的信息是有效的。当此位为零时，地址是针对“基本”功能。<br>注意：虚拟功能ID对于物理地址（ReqVirtAddr=0）或虚拟地址（ReqVirtAddr=1）都是有效的。</td><td>Virtual Address Feature</td></tr><tr><td><em><a href=#reqvfid>ReqVfid</a></em></td><td>N <em><a href=#vf>vf</a></em></td><td>Originator</td><td>Request虚拟功能ID。<br>此信号指示此请求的虚拟功能ID。<br>如果ReqVfidValid = 0，此Field保留。</td><td>Virtual Address Feature</td></tr><tr><td><em><a href=#requnitid>ReqUnitID</a></em></td><td>N <em><a href=#ui>ui</a></em></td><td>Originator</td><td>请求者unitID。<br>标识发起事务的Originator内的unit。此Field的默认值为0。</td><td>Yes，除了将Tag空间展平的CS。</td></tr><tr><td><em><a href=#reqstreamid>ReqStreamID</a></em></td><td>N <em><a href=#si>si</a></em></td><td>Originator</td><td>Request流ID。<br>标识ReqUnitID内的特定有序流。此Field的默认值为0。</td><td>I/O Stream feature</td></tr><tr><td><em><a href=#reqseclevel>ReqSecLevel</a></em></td><td>N <em><a href=#rsl>rsl</a></em></td><td>Originator</td><td>Request安全级别。<br>指示请求的安全特权级别。</td><td>Secure transaction feature</td></tr><tr><td><em><a href=#reqtmz>ReqTMZ</a></em></td><td>1</td><td>Originator</td><td>Request TMZ。<br>标识请求正在访问可信内存区域。</td><td>Trusted Memory feature</td></tr><tr><td><em><a href=#reqpasspw>ReqPassPW</a></em></td><td>1</td><td>Originator</td><td>Request通过posted写入。<br>适用于posted和non-posted虚拟通道中的请求。- 1：此请求可以通过同一方向的posted写入。- 0：此请求不得通过posted写入。如果未实现，当请求在posted或non-posted通道中时，处理方式如同此Field设置为0，否则为1。</td><td>Posted write ordering feature</td></tr><tr><td><em><a href=#reqblocklevel>ReqBlockLevel</a></em></td><td>2</td><td>Originator</td><td>Request阻塞级别。<br>指示此请求在同一虚拟通道内阻塞在早期请求后面所需的源匹配级别。有关更多信息，请参见下文的 <em><a href=#reqblocklevel>ReqBlockLevel</a></em> 。</td><td>Request Ordering和I/O Stream features</td></tr><tr><td><em><a href=#reqrsppasspw>ReqRspPassPW</a></em></td><td>1</td><td>Originator</td><td>Request响应通过posted写入。<br>仅适用于non-posted虚拟通道中的请求。- 1：对此请求的响应可以通过同一方向的posted写入。- 0：对此请求的响应不得通过posted写入。如果未实现，处理方式如同此Field设置为1。</td><td>Posted write ordering feature</td></tr><tr><td><em><a href=#reqvc>ReqVC</a></em></td><td>N <em><a href=#rvc>rvc</a></em></td><td>Originator</td><td>Request虚拟通道。<br>指定请求的虚拟通道。如果未实现，Completer或Completer代理确定请求的虚拟通道。</td><td>Virtual Channel Support</td></tr><tr><td><em><a href=#reqchain>ReqChain</a></em></td><td>1</td><td>Originator</td><td>Request链。<br>这是一个提示，指示Originator期望将此请求与同一VC中的后续请求分组在一起是有利的。<br>旨在用于fabric和目的地内的仲裁逻辑，以提高效率将请求分组在一起。</td><td>Request Chain feature</td></tr><tr><td><em><a href=#reqparity>ReqParity</a></em></td><td>1</td><td>Originator</td><td>Request奇偶校验。<br>在Originator端口上维护所有由Originator驱动的Originator请求通道信号的偶校验，排除ReqAddr、ReqSubAddr、ReqSpecialAddr、ReqIO、ReqVld、ReqClkEn_m1和ReqCreditRdy。</td><td>Enhanced RAS V1 feature</td></tr><tr><td><em><a href=#reqaddrparity>ReqAddrParity</a></em></td><td>1</td><td>Originator</td><td>Request地址奇偶校验。<br>维护ReqAddr、ReqSubAddr、ReqSpecialAddr和ReqIO的偶校验。<br>实现注意：ReqAddrParity和ReqParity的分离是为了减少奇偶校验树的大小，不应暗示某些Field在奇偶校验检查中比其他Field更关键。如果支持Enhanced RAS V1特性，所有端口都必须实现ReqParity和ReqAddrParity。</td><td>Enhanced RAS V1 feature</td></tr><tr><td><em><a href=#reqchanab>ReqChanAB</a></em></td><td>1</td><td>Originator</td><td>Request通道A/B选择。<br>仅对Completer端口定义。- 0：请求使用通道A。- 1：请求使用通道B。</td><td>Physical Channel Multiplexing feature</td></tr><tr><td><em><a href=#reqcachehint>ReqCacheHint</a></em></td><td>1或2</td><td>Originator</td><td>此Field为在fabric或Completer内部的任何缓存（读取时，包括缓存和非缓存）、写入、victims和原子操作的分配提供提示。<br>上述fabric或Completer缓存的实现以及Originator应利用此Field的条件超出了本规范的范围。<br>此Field保留用于缓存维护、屏障和其他命令。<br>当使用SpecPrefCmd时，此Field被忽略，因为ReqAttr指定了等效功能。在先前的规范中，此Field只有1位，名为ReqNoAlloc。实现仍可以向后兼容的方式为此Field提供单个位，并假定ReqCacheHint[1]=0b。</td><td>External Last Layer Cache feature</td></tr><tr><td><em><a href=#reqstwayid>ReqStWayId</a></em></td><td>N <em><a href=#st>st</a></em></td><td>Originator</td><td>在RdBlkS和一致性WrSized*命令期间断言时，此Field指示Originator的缓存路标识符，将在此事务的结果中更新and/or失效。<br>当ReqStUpdate和ReqStInvalidate都为零时，此Field保留。</td><td>Cache Tag Tracking feature</td></tr><tr><td><em><a href=#reqstupdate>ReqStUpdate</a></em></td><td>1</td><td>Originator</td><td>此Field指定必须执行的缓存Tag跟踪更新。<br>有关更多信息，请参见 <em><a href=#reqstwayid>ReqStWayId</a></em> 、<em><a href=#reqstwayid>ReqStWayId</a></em> 、<em><a href=#reqstinvalidate>ReqStInvalidate</a></em> 。<br>对于除缓存命令（RdBlk*）和一致性WrSized*之外的所有命令，此Field保留，且必须为零。</td><td>Cache Tag Tracking feature</td></tr><tr><td><em><a href=#reqstinvalidate>ReqStInvalidate</a></em></td><td>1</td><td>Originator</td><td>此Field指定必须执行的缓存Tag跟踪更新。<br>有关更多信息，请参见 <em><a href=#reqstwayid>ReqStWayId</a></em> 、<em><a href=#reqstwayid>ReqStWayId</a></em> 、<em><a href=#reqstinvalidate>ReqStInvalidate</a></em> 。<br>对于除缓存命令（RdBlk*）和一致性WrSized*之外的所有命令，此Field保留，且必须为零。</td><td>Cache Tag Tracking feature</td></tr><tr><td><em><a href=#reqcompmode>ReqCompMode</a></em></td><td>2</td><td>Originator</td><td>此Field指定请求的压缩模式。<br>此Field的编码与命令相关。参见 <em><a href=#reqcompmode>ReqCompMode</a></em> 。</td><td>Metadata Compression feature</td></tr><tr><td><em><a href=#reqspecdatafetch>ReqSpecDataFetch</a></em></td><td>2</td><td>Originator</td><td>参见 <em><a href=#reqspecdatafetch>ReqSpecDataFetch</a></em> 。</td><td>Metadata Compression feature</td></tr><tr><td><em><a href=#reqvld>ReqVld</a></em></td><td>1</td><td>Originator</td><td>Request有效。<br>此信号用于为时钟同步目的调节来自Originator的请求流。</td><td>Yes</td></tr><tr><td><em><a href=#reqclken_m1>ReqClkEn_m1</a></em></td><td>1</td><td>Originator</td><td>Request时钟使能。<br>ReqClkEn_m1必须在ReqVld断言前一个时钟周期断言。</td><td>Low-Power Signaling feature</td></tr><tr><td><em><a href=#reqrdy>ReqRdy</a></em></td><td>1</td><td>Port或pervasive logic</td><td>Request就绪。<br>此信号用于为时钟同步目的调节跨接口的请求流。有关*Rdy / *Vld握手的更多信息，请参见 <em><a href="#2.4 信号要求">2.4 信号要求</a></em> 。</td><td>Yes</td></tr><tr><td><em><a href=#reqcreditchanab>ReqCreditChanAB</a></em></td><td>1</td><td>Port</td><td>Request credit通道A/B。<br>仅对Completer端口定义。<br>- 0：Credit用于通道A。- 1：Credit用于通道B。</td><td>Physical Channel Multiplexing feature</td></tr><tr><td><em><a href=#reqcredittype>ReqCreditType</a></em></td><td>1</td><td>Port</td><td>Request credit类型。<br>- 0：正在释放的credit用于特定的虚拟通道，由ReqCreditVC给出。- 1：正在释放的credit是一个池credit，可用于任何虚拟通道中的请求。<br>如果未实现，此Field将被视为设置为0。</td><td>Virtual Channel Support</td></tr><tr><td><em><a href=#reqcreditvc>ReqCreditVC</a></em></td><td>N <em><a href=#rcv>rcv</a></em></td><td>Port</td><td>Request credit虚拟通道。<br>如果ReqCreditType = 0，此Field指定正在释放的credit的虚拟通道。<br>如果ReqCreditType = 1，此Field被忽略。<br>如果此Originator未实现虚拟通道，此Field将被视为设置为0。</td><td>Virtual Channel Support</td></tr><tr><td><em><a href=#reqcreditparity>ReqCreditParity</a></em></td><td>1</td><td>Port</td><td>Request credit奇偶校验。<br>维护除ReqCreditVld、ReqCreditClkEn_m1和ReqCreditRdy之外的ReqCredit*Field的偶校验。</td><td>Enhanced RAS V3 feature</td></tr><tr><td><em><a href=#reqcreditcnt>ReqCreditCnt</a></em></td><td>N <em><a href=#cc>cc</a></em> <em><a href=#[0]><sup>[0]</sup></a></em></td><td>Port</td><td>返回的credit数量的零原点Field。</td><td>Credit Count Feature</td></tr><tr><td><em><a href=#reqcreditvld>ReqCreditVld</a></em></td><td>1</td><td>Port</td><td>Request credit有效。<br>由端口（或Completer）在credit释放子通道上提供的信息是有效的。有关更多信息，请参见 <em><a href=#ReqCreditVld>ReqCreditVld</a></em> 。</td><td>Yes</td></tr><tr><td><em><a href=#reqcreditclken_m1>ReqCreditClkEn_m1</a></em></td><td>1</td><td>Port</td><td>Request credit时钟使能。<br>ReqCreditClkEn_m1必须在ReqCreditVld断言前一个时钟周期断言。</td><td>Low-Power Signaling feature</td></tr><tr><td><em><a href=#reqcreditrdy>ReqCreditRdy</a></em></td><td>1</td><td>Originator或pervasive logic</td><td>Request credit就绪。<br>此信号用于为时钟同步目的调节跨接口的请求credit信息流。有关*Rdy / *Vld握手的更多信息，请参见 <em><a href="#2.4 信号要求">2.4 信号要求</a></em> 。</td><td>Yes</td></tr><tr><td><em><a href=#requser>ReqUser</a></em></td><td>—</td><td>Originator</td><td>用户定义Field。<br>如果实现，信息必须与请求通道的方向相同。</td><td>User-defined</td></tr></tbody></table><p>Originator设备使用Originator请求通道来启动与系统内存空间之间的数据传输。
请求的数据量以及传输类型由地址指示。可以请求的最小数据量是一个双字。
携带信息的物理通道（RdRspData或OrigData）的数据Field大小以内的数据可以在一个时钟周期（一个节拍）内传输。
更大量的数据以一系列节拍（一个突发）的形式传输。
有关数据如何在接口上传输的讨论，请参见 <em><a href="#3.2 数据传输">3.2 数据传输</a></em> 。</p><p>Originator请求通道的Field在以下章节中进一步描述。</p><hr><p><strong><a id=reqtag>ReqTag</a></strong></p><p>此Field标识由Originator设备的特定功能unit（由其UnitID标识）发起的每个未完成请求。Originator的每个unit都被分配自己独立的一组Tag。</p><p>在接收到响应的最后一拍（没有RETRANSMIT或EARLY）之前，每个功能unit不得重用一个ReqTag。
当响应头和响应数据之间存在延迟时，如果响应头中的信息允许功能unit预测响应数据状态将不会是RETRANSMIT，而无需等待数据，那么功能unit也可以重用ReqTag。
除了Cancel命令外，当一个请求没有响应（如QosControl、SpecDramRd和ErrEvent）时，ReqTag Field是无意义的。</p><p>对于需要Originator明确确认的事务，在Originator通过响应确认通道发送与请求相同的unitID（AckUnitID）和Tag（AckTag）的响应确认之前，这些事务并未完成。
但是，Originator可以在发送响应确认之前重用Tag，前提是并且仅当它承诺发送此确认时，除了Response Acknowledge credit和AckRdy之外没有任何依赖；
并且仅当它承诺按照接收响应的顺序发送重复Tag的响应确认。
有关响应确认通道信号的更多信息，请参见 <em><a href="#2.2.9 响应确认通道">2.2.9 响应确认通道</a></em> 。
<em><a href="#表 40 命令">表 40 命令</a></em> 指出了哪些命令需要Originator的确认。</p><hr><p><strong><a id=reqaddr>ReqAddr</a></strong></p><p>对于非缓存读取、原子操作和写入（包括WrNoDataNC），此Field提供正在访问的数据的字节地址，或者，在系统管理命令的情况下，提供管理功能的更多细节。</p><p>对于缓存读取、缓存升级、缓存驱逐和缓存维护命令，ReqAddr提供正在访问的数据的缓存行地址。
缓存行地址以下的ReqAddr位不使用，通常保留。
然而，对于缓存读取和ChgToX，ReqAddr指定请求的对齐缓存块内的关键字节。如果可能，包含关键字节的节拍应在其他节拍之前传输。</p><p>始终执行n字节对齐操作的接口可以省略位[log2n-1:0]。ReqAddr[1:0]始终是可选的。地址是小端序的。</p><hr><p><strong><a id=reqsubaddr>ReqSubAddr</a></strong></p><p>在本节中，寻址缓存行大小一半的地址位将被称为地址位“x”（即在具有64字节缓存行的实现中，x是第5位）。
此外，本节将引用一个“ReqAddr2”，可以通过ReqAddr和ReqSubAddr之间的算术操作确定，尽管ReqAddr2不是SDP端口上的一个Field。</p><p>当实现了多请求地址特性，并且ReqSubAddr非零时，事务由一个单一的合并SDP请求中的两个具有不同地址的独立逻辑事务组成。
除了地址外，这两个逻辑事务的所有其他Field（例如ReqCmd、ReqAttr、ReqSecLevel、ReqVC等）必须相同。
然后，Completer访问这两个独立的地址，并返回响应和数据（对于读取）给两个地址。</p><p>多请求地址特性的目的是优化在Completer使用两个子通道一起操作以执行缓存行大小访问的系统。
在这些实现中，每当Originator进行子缓存行大小的请求时，Completer带宽的使用效率就会降低。
为了恢复带宽，Originator可以指定两个独立的半缓存行大小的请求——一个使用ReqAddr用于第一个子通道，另一个使用ReqSubAddr用于第二个子通道。
Originator必须确保ReqAddr映射到第一个子通道，ReqAddr2（第二个地址）映射到第二个子通道。
如果不是这种情况，可能会发生不可预知的结果。通常，这需要Originator具有一个地址位选择子通道的映射。</p><p>Completer通过以下XOR操作创建ReqAddr2：</p><ul><li><strong>ReqAddr2[x:0]</strong> 基于子通道选择逻辑隐含确定。</li><li>对于在ReqSubAddr中指定的地址位，<strong>ReqAddr2[n] = ReqAddr ^ ReqSubAddr</strong>。</li><li>对于未在ReqSubAddr中指定的地址位（除了特定的x之外），<strong>ReqAddr2 = ReqAddr</strong>。</li></ul><p>由于只有某些地址位在两个逻辑事务之间可能不同，Field ReqSubAddr的宽度与ReqAddr不同。
此外，指定的地址位可能不是连续的。
例如，ReqSubAddr[0]可能映射到地址位7，ReqSubAddr[1]可能映射到地址位9。
在创建ReqAddr2的XOR操作期间，Completer假定所有未实现的位为零，除了地址位“x”，它未被指定但被适当地设置以选择另一个子通道。
哪些地址位在ReqSubAddr中指定以及ReqSubAddr[a]到ReqAddr[b]的映射是实现相关的。
通常，预计Originator和Completer会有配置位来指定ReqSubAddr到ReqAddr位的这种映射。
注意，在事务中ReqAddr[x]不一定为零，因为ReqAddr[x]可能是选择两个子通道之间的位之一。
如果不考虑多请求地址特性，这会导致SDP事务似乎跨越一个缓存行。ReqSubAddr中的非零值表明正在访问两个独立的缓存行。</p><p>在以下情况下，ReqSubAddr是保留的，且必须为零：</p><ul><li>缓存读取（RdBlk*）、缓存驱逐命令（VicBlk*）、SpecDramRd和缓存升级命令。</li><li>对于ReqLen不等于缓存行长度的非缓存请求。</li><li>当ReqIO=1或ReqSpecialAddr=1时。</li><li>取决于实现，对于一致性读取或写入。在本规范发布时，没有SOC-15实现允许一致性请求使用ReqSubAddr。</li><li>取决于实现，对于原子命令。在本规范发布时，没有SOC-15实现允许原子请求使用ReqSubAddr。</li><li>WrNoDataNC。</li></ul><p>当ReqAddr Field保留或被忽略时（例如Fence、Flush、ErrEvent、QosControl），则ReqSubAddr也是保留的，且必须为零。</p><p>虽然两个逻辑请求的长度都是缓存行的一半，但在SDP端口上的合并请求和ReqLen是一个缓存行（即，对于具有64字节缓存行的实现，ReqLen为0xF）。</p><p>Completer始终在一个单一的读取完成或写入完成中返回响应。
数据根据子通道进行寻址——最低有效数据字节（从0到缓存行大小的一半减1）用于第一个事务和第一个子通道（ReqAddr）。
最高有效字节（从缓存行大小的一半到缓存行大小减1）用于第二个事务和第二个子通道（ReqAddr2），无论ReqAddr[x]的值如何。
由于可能有多个地址位用于选择子通道，用于事务数据的字节通道可能不是Originator进行两个独立事务时使用的字节通道。</p><p>对两个地址中的任何一个的错误都会导致整个事务出错。Completer遵循所有其他规则，包括排序，就像这些请求是两个独立的请求一样。</p><hr><p><em><a href="#reqspecialaddr 和 reqio">ReqSpecialAddr 和 ReqIO</a></em></p><p>ReqSpecialAddr 和 ReqIO 用于确定地址的编码。
当 ReqAddr 是物理地址（ReqVirtAddr=0 或不存在虚拟地址特性）时，地址可能被编码为“系统或设备/本地内存”、“IO 内存”，或者可能被编码为系统管理功能。
Fields ReqSpecialAddr 和 ReqIO 确定地址类型，如表5 ReqIO 和 ReqSpecialAddr 编码所示。
当端口需要访问物理地址空间末尾12GB区域之外的系统消息时，必须使用 ReqSpecialAddr。否则，“系统内存”地址限制为 2^ReqAddr 大小减去 12GB。</p><p>在适配器上，“IO 内存”也包括“主机内存”（所有不在适配器上的内存）。“系统内存”和“IO 内存”的确切含义可能取决于系统。</p><p>对于 CPU Originator，I/O 空间特性（ReqIO）允许使用 x86 架构特性，其中物理地址可以动态地映射到 I/O 或系统内存空间。
预计这种动态映射不会在非 x86 实现中出现。</p><p><a id="表5 reqio 和 reqspecialaddr 编码">表5 ReqIO 和 ReqSpecialAddr 编码</a></p><p><strong>表5 ReqIO 和 ReqSpecialAddr 编码</strong></p><table><thead><tr><th>ReqSpecialAddr</th><th>ReqIO</th><th>ReqVirtAddr</th><th>端口类型</th><th>访问类型</th></tr></thead><tbody><tr><td>0</td><td>0</td><td></td><td>CPU</td><td>使用物理（翻译后）地址访问“系统”内存。</td></tr><tr><td>0</td><td>1</td><td>0（未实现）</td><td>CPU</td><td>使用物理（翻译后）地址访问 I/O。</td></tr><tr><td>1</td><td>0 或 1（无关）</td><td></td><td>CPU</td><td>访问系统消息空间（参见 <em><a href="#3.10 系统消息">3.10 系统消息</a></em> ）。</td></tr><tr><td>0</td><td>0</td><td>0</td><td>非 CPU</td><td>使用物理（翻译后）地址访问“本地”内存。</td></tr><tr><td>0</td><td>1</td><td>0</td><td>非CPU</td><td>使用物理（翻译后）地址访问“主机”内存或 I/O 内存。</td></tr><tr><td>0</td><td>1</td><td>0</td><td>非CPU</td><td>使用预翻译地址访问“本地”、“主机”或 I/O 内存。</td></tr><tr><td>0</td><td>1</td><td>1</td><td>非CPU</td><td>使用虚拟地址进行访问（ReqVirtAddr 已设置）。</td></tr><tr><td>1</td><td>0</td><td>0</td><td>非CPU</td><td>访问系统消息空间（ <em><a href="#3.10 系统消息">3.10 系统消息</a></em> ）。</td></tr></tbody></table><p><strong>注意：</strong></p><ol><li><p>当端口上未实例化 ReqSpecialAddr 或 ReqVirtAddr 时，Field 被视为零。</p></li><li><p>当未实例化 ReqSpecialAddr 时，所有系统消息都通过解码地址来识别。如果未实例化 ReqSpecialAddr，则只能使用系统管理的最后 12GB 中的系统地址。</p></li></ol><p><strong><a id=reqlen>ReqLen</a></strong></p><p>此 Field 指定要传输的双字数量。指示的transfer Size为 (ReqLen + 1)。
此大小可以小于用于传输数据的读响应或 Originator 数据通道的 *Data Field 的宽度。此 Field（Nrl）的宽度是实现相关的。</p><p>对于所有具有写语义但没有数据负载的命令，如 VicBlkCln、WrNoDataNC、Fence、Flush，以及缓存维护命令（如 WbInvBlkAll），ReqLen Field 保留。
对于这些命令，ReqLen Field 必须设置为 0。</p><p>对于在缓存块上操作的命令，例如缓存读取（RdBlk*）、缓存升级（ChgToX、ChgToXNR、ValBlk）、除 VicBlkCln 之外的缓存驱逐命令（VicBlkFull*、VicBlkClnD、VicBlkPtl），以及缓存维护命令（ClnBlkAll、WbInvBlkAll 和 InvBlkAll），ReqLen 预计指示缓存块的大小。</p><hr><p><strong><a id=reqack>ReqAck</a></strong></p><p>大多数请求定义了此 Field 的值，但对于不需要在先前请求之后排序的请求，某些请求允许可选地将其清除。
有关使用响应确认特性的命令的定义，请参见 <em><a href="#3.10 命令">3.10 命令</a></em> 。</p><hr><p><strong><a id=reqattr>ReqAttr</a></strong></p><p>提供关于事务请求的特定属性信息。编码取决于请求的类型，如以下表格所示。对于本节未包含的任何命令，ReqAttr 保留。
ReqAttr 中所有保留位必须为零。</p><p><strong>表6 WrSized、WrSizedFull、WrSizedFullZero、WrSizedFullComp 和缓存读取请求的 ReqAttr 用法</strong></p><table><thead><tr><th>位范围</th><th>子字段（Steering = 0）<br>Caching Reads</th><th>子字段（Steering = 0）<br>WrSized</th><th>子字段（Steering = 1）WrSized</th></tr></thead><tbody><tr><td>7:6</td><td>保留</td><td>对于 WrSizedFullComp：transfer Size<br>对于其他 WrSized：Metadata Compression</td><td>Steering Tag[6:0]</td></tr><tr><td>5</td><td>保留</td><td>保留</td><td>Steering Tag[6:0]</td></tr><tr><td>4:3</td><td>Prefetch Hint[1:0]</td><td>Prefetch Hint[1:0]</td><td></td></tr><tr><td>2</td><td>保留</td><td>Cache State [1:0]</td><td>Steering Tag[6:0]</td></tr><tr><td>1</td><td>Storing Probe Fetch</td><td>Cache State [1:0]</td><td>Steering Tag[6:0]</td></tr><tr><td>0</td><td>保留（0b）</td><td>Steering</td><td>Steering</td></tr></tbody></table><p><strong>Steering Tag</strong></p><ul><li>Steering Tag 是对系统中某组件（如缓存）的指示或提示，数据可能被定向（写入）或来源（读取）于此。</li><li>Steering Tag 的编码超出了本文档的范围。</li><li>建议使用 0000000b 表示“无特定的 Steering Tag”，
此情况下，Completer 或 Fabric 可使用实现特定的算法来选择数据定向的组件。
在这种用例中，Steering=1 仅表示 Completer 或 Fabric 可能希望定向数据。</li></ul><p><strong>Prefetch Hint</strong></p><ul><li>00b = 无Prefetch Hint</li><li>01b、10b、11b = 保留</li></ul><p><strong>Cache State</strong>（仅适用于
WrSized/WrSizedFull/WrSizedFullZero/WrSizedFullComp），指示一致性 Originator 的Cache State：</p><ul><li>0xb = 未知或任意；可能对 Originator 进行探测。</li><li>10b = 已知无效或无关；不会对 Originator 进行探测。</li><li>11b = 共享；不会对 Originator 进行探测。此编码适用于 Originator 已经更新其缓存的写直达缓存。</li></ul><p><strong>transfer Size</strong></p><ul><li>00b = 保留</li><li>01b = 半大小压缩——即当 ReqLen=0xF 时实际发送 32 个压缩字节，当 ReqLen=0x7 时发送 16 个压缩字节。注意：当使用字节使能压缩时，如果任何节拍用于传输字节使能，transfer Size不变。</li><li>1xb = 保留</li></ul><p><strong>Metadata Compression</strong></p><ul><li>00b = 写数据未压缩。ReqLen 指示未压缩数据的大小。</li><li>01b = 写数据已压缩。未压缩长度为 128B（ReqLen 指示压缩数据的大小）。</li><li>10b = 写数据已压缩。未压缩长度为 256B（ReqLen 指示压缩数据的大小）。</li><li>11b = 保留</li></ul><p>如果未实现 Metadata Compression 特性，对于 WrSized* 命令，ReqAttr 的Metadata Compression Field 保留，且必须为 00b。参见 MetaData Compression。</p><p><strong>Storing Probe Fetch</strong></p><ul><li>0b = 此缓存读取不是存储探测的结果。
Completer 不会对这些缓存读取使用 RdRspStatus=OKAY_NODATA 进行响应。</li><li>1b = 此缓存读取是在存储探测导致 CPU 获取该行后生成的结果。
Completer 在某些情况下可能返回 RdRspStatus=OKAY_NODATA。</li></ul><hr><p><strong><a id="表 7 chgtox、chgtoxnr、valblk 请求的 reqattr 用法">表 7 ChgToX、ChgToXNR、ValBlk 请求的 ReqAttr 用法</a></strong></p><table><thead><tr><th>位范围</th><th>子字段</th></tr></thead><tbody><tr><td>ReqAttr[7:3]</td><td>保留</td></tr><tr><td>ReqAttr[2:1]</td><td>Cache State</td></tr><tr><td>ReqAttr[0]</td><td>保留</td></tr></tbody></table><p><strong>Cache State</strong>指示一致性 Originator 的Cache State：</p><ul><li>0xb = 未知或任意；可能对 Originator 进行探测。</li><li>10b = 已知无效或无关；不会对 Originator 进行探测。</li><li>11b = 共享或已拥有；不会对 Originator 进行探测（当使用此编码时，Originator 必须正确维护Cache State）。</li></ul><hr><p>**<a id="表 8 rdsized、rdsizednc 的 reqattr 用法">表 8 RdSized、RdSizedNC 的 ReqAttr 用法</a> **</p><table><thead><tr><th>事务类型</th><th>位范围</th><th>子字段</th></tr></thead><tbody><tr><td>Device Peer-to-Peer Messages</td><td>ReqAttr[7:0]</td><td>用户定义。由 Fabric 携带，从源到目的地不变。</td></tr><tr><td>其他</td><td>ReqAttr[7:4]</td><td>字节使能，最后一个双字。如果最后一个双字也是第一个双字，则忽略。</td></tr><tr><td>其他</td><td>ReqAttr[3:0]</td><td>字节使能，第一个双字。</td></tr></tbody></table><p>注意：如果读取比请求的字节数更多，对于没有副作用的情况（如 DRAM 读取），Completer 可能会忽略字节使能。</p><hr><p>**<a id="表 9 原子请求的 reqattr 用法">表 9 原子请求的 ReqAttr 用法</a> **</p><table><thead><tr><th>位范围</th><th>子字段</th></tr></thead><tbody><tr><td>ReqAttr[7:4]</td><td>Operation Type（OpType）。参见 <em><a href="#3.6.3 原子操作">3.6.3 原子操作</a></em> 。</td></tr><tr><td>ReqAttr[3:2]</td><td>Operand Size（OpSize）。参见 <em><a href="#3.6.3 原子操作">3.6.3 原子操作</a></em> 。</td></tr><tr><td>ReqAttr[1]</td><td>保留</td></tr><tr><td>ReqAttr[0]</td><td>Operation Type Extension （OpTypeExt），当实现 Floating Point Atomic 特性时。未实现时保留（必须为零）。参见 <em><a href="#3.6.3 原子操作">3.6.3 原子操作</a></em> 。</td></tr></tbody></table><hr><p><strong><a id="表 10 wrsizednc 的 reqattr 用法">表 10 WrSizedNC 的 ReqAttr 用法</a></strong></p><table><thead><tr><th>位范围</th><th>含义</th></tr></thead><tbody><tr><td>ReqAttr[7:0]</td><td>非 SOC15 Fabric 端口：用户定义<br>SOC15 Fabric 端口：对于“Device Peer-to-Peer Message region””中的事务，ReqAttr 是用户定义的。<br>Fabric 从源到目的地不变地携带该字段。对于包括 DRAM 事务在内的所有其他事务，ReqAttr[7:0] 保留。</td></tr></tbody></table><hr><p><strong><a id="表 11 Victim Block 的 ReqAttr 用法">表 11 Victim Block 的 ReqAttr 用法</a></strong></p><table><thead><tr><th>位范围</th><th>子字段</th></tr></thead><tbody><tr><td>ReqAttr[7:6]</td><td>TransferSize。<br>仅对 VicBlkFullComp 有效，对所有其他命令保留<br>- 00b：保留<br>- 01b：半大小压缩——对于 64 字节的数据实际发送 32 个压缩字节<br>- 1xb：保留<br>注意：ReqAttr[7:6] 在 SOC-15 Fabric 内部用于非压缩命令。</td></tr><tr><td>ReqAttr[5]</td><td>保留。<br>注意：ReqAttr[5] 在 SOC-15 Fabric 内部使用。</td></tr><tr><td>ReqAttr[4:3]</td><td>CurrentState。<br>仅对 VicBlkClnD 有效，对 VicBlkFull*、VicBlkPtl 和 VicBlkCln 保留<br>- 00b：保留<br>- 01b：正在驱逐的缓存行当前状态为共享（S）状态<br>- 10b：当前状态为前进（F）状态<br>- 11b：正在驱逐的缓存行当前状态为独占（E）状态<br>当缓存发送一个 VicBlkClnD 的独占（E）行并保留该行的共享副本时，必须考虑降级后的当前状态。例如，对独占（E）行的干净驱逐，最终状态为共享（01b），则 CurrentState 应表示为前进（10b），而不是独占（11b）。</td></tr><tr><td>ReqAttr[2]</td><td>NoAlloc。<br>如果 NoAlloc = 1，提供一个提示，表明被 Victim 的缓存块不应在系统内存缓存层次结构的更高层中分配。仅适用于 VicBlkFull*。对于 VicBlkCln、VicBlkClnD 和 VicBlkPtl，此字段保留。</td></tr><tr><td>ReqAttr[1:0]</td><td>FinalState：<br>- 00b：该行的最终状态为无效（I）<br>- 01b：缓存已保留该行的共享（S）状态<br>- 10b：缓存已保留该行的独占（E）状态。对 VicBlkCln 和 VicBlkClnD 保留<br>- 11b：缓存已保留该行的前进（F）状态</td></tr></tbody></table><hr><p><strong>表12 ErrEvent 的 ReqAttr 用法</strong></p><table><thead><tr><th>位范围</th><th>子字段</th></tr></thead><tbody><tr><td>7:0</td><td>ErrorType：<br>- 00h：保留<br>- 01h：系统级别的致命不可恢复（“SYNCFLOOD”）错误<br>- 02h–FFh：保留</td></tr></tbody></table><hr><p><strong><a id=ReqQosForward>ReqQosForward</a></strong></p><p>此字段的编码如 <em><a href="#表 表13 reqqosforward 编码所示">表 表13 ReqQosForward 编码所示</a></em> 。</p><p><strong><a id="表 13 reqqosforward 编码">表 13 ReqQosForward 编码</a></strong></p><table><thead><tr><th>ReqQosForward[1:0]</th><th>其他受影响的请求（Originator 端口）</th><th>其他受影响的请求（Completer 端口）</th></tr></thead><tbody><tr><td>00b</td><td>仅具有相同的 Tag</td><td>按 Tag 升级</td></tr><tr><td>01b</td><td>所有具有相同 ReqUnitID 的请求</td><td>在 ReqVC 中升级读取</td></tr><tr><td>10b</td><td>来自此端口的所有请求</td><td>在 ReqVC 中升级写入</td></tr><tr><td>11b</td><td>同一 VC 中的所有请求</td><td>保留</td></tr></tbody></table><p>Fabric 可以选择升级比必要更多的请求，以简化升级的跟踪。
实现 QoS 特性的端口实现可以将其作为在 Originator 请求通道上指示当前请求优先级的方法，而不需要任何优先级转发。
在这种情况下，Originator 始终将 ReqQosForward=00b。允许的实现可以完全不实例化 ReqQosForward 字段，并将其视为 ReqQosForward == 00b。</p><hr><p><strong><a id="表 14 addrxlaterdsz 和 addrxlatewrsz 的 reqattr 用法">表 14 AddrXlateRdSz 和 AddrXlateWrSz 的 ReqAttr 用法</a></strong></p><table><thead><tr><th>位范围</th><th>AddrXlateRdSz 用法</th><th>AddrXlateWrSz 用法</th></tr></thead><tbody><tr><td>ReqAttr[7:5]</td><td>权限字段——{EXECUTE, WRITE, READ}。指定翻译所请求的权限级别。</td><td>保留</td></tr><tr><td>ReqAttr[4:3]</td><td>保留</td><td>保留</td></tr><tr><td>ReqAttr[2:0]</td><td>子命令<br>- 000b = “地址翻译”<br>其他子命令编码保留。</td><td>子命令<br>- 000b = “地址失效”<br>其他子命令编码保留。</td></tr></tbody></table><hr><p><strong><a id="表 15 specprefcmd 的 reqattr 用法">表 15 SpecPrefCmd 的 ReqAttr 用法</a></strong></p><table><thead><tr><th>位范围</th><th>用法</th></tr></thead><tbody><tr><td>ReqAttr[7:6]</td><td>PrefetchType：<br>- 00b：无响应。此类型的命令可在任何地方被丢弃。<br>- 01b：保留<br>- 10b：返回无数据的响应<br>- 11b：返回带数据的响应<br>有关更多信息，请参见 SpecDramRd/SpecPrefCmd。</td></tr><tr><td>ReqAttr[5:4]</td><td>LlcPrefetchCmd：<br>- 00b：正常地址和分配策略适用<br>- 01b：检索 Completer 缓存（先前分配的数据）<br>- 10b：预取并在 Completer 缓存中分配<br>- 11b：保留</td></tr><tr><td>ReqAttr[3:0]</td><td>保留</td></tr></tbody></table><hr><p><strong><a id=reqcmd>ReqCmd</a></strong></p><p>此字段指示此请求的命令。有关命令列表及其编码，请参见 <em><a href="#3.6 命令">3.6 命令</a></em> 。
当 ReqCmd[5] 为 1b 时，Originator 还必须在 Originator 数据通道上传输数据。
除了 Originator 请求通道的流控制外，还必须根据通道流控制中定义，获得一个或多个 Originator（写入/探测）数据通道的 credit。
参见 <em><a href="#3.4 通道流控制">3.4 通道流控制</a></em></p><hr><p>**<a id=reqdomain>ReqDomain</a> **</p><p>此信号指示请求的可共享域。每个一致性 Originator 端口都表现为单个缓存实体，无论其背后有多少缓存或缓存级别。此字段的编码如 *<a href="#表 16 reqdomain 编码">表 16 ReqDomain 编码</a>*所示。</p><p><strong><a id="表 16 ReqDomain 编码*">表 16 ReqDomain 编码*</a></strong></p><table><thead><tr><th>值</th><th>属性</th><th>含义</th></tr></thead><tbody><tr><td>0</td><td>内部可共享</td><td>请求在为该地址定义的其他 Originator 子集（称为可共享域）内是一致的。仅需要对域内的 Originator 进行探测。该子集的确定超出了本规范的范围。</td></tr><tr><td>1</td><td>外部可共享</td><td>SDP Originator 与系统中针对该地址的所有其他 SDP Originator 保持一致，需要对所有 Originator 进行探测。</td></tr></tbody></table><p>可共享域用于在仅有一部分 Originator（将参与同一域）已知正在使用内存区域时，限制维持一致性所需的探测事务的范围和数量。
例如，这可以用于允许一组多媒体处理器使用缓存一致的访问方式访问特定的内存区域，同时将探测限制为仅针对与该处理器组关联的缓存。</p><hr><p><strong><a id=requnitid>ReqUnitID</a></strong></p><p>请求者unit ID。标识发起事务的 Originator 内的unit。对于来自 CPU 的请求，ReqUnitID 标识发出请求的线程。
这用于线程特定的寄存器访问（如 MSR 和 APIC 空间）、安全检查和调试。</p><hr><p><strong><a id=reqstreamid>ReqStreamID</a></strong></p><p>标识 ReqUnitID 内的特定有序流。</p><hr><p><strong><a id=reqseclevel>ReqSecLevel</a></strong></p><p>指示请求的安全特权级别。</p><hr><p><strong><a id=reqpasspw>ReqPassPW</a></strong></p><p>当 ReqVC 指定一个 posted 或 non-posted 虚拟通道（在上行或下行方向）时，ReqPassPW 指定（当为 0 时）此请求必须与先前的 posted 写入（无论地址或目的地）保持顺序。
有关更多信息，请参见 <em><a href="#3.7 排序">3.7 排序</a></em> 。</p><p>在“上行”方向上，ReqPassPW 顺序仅在上行事务到达 PCIe 接口后建立，如果上行 posted 和 non-posted 虚拟通道是分开的，则在 Fabric 内不会建立。
Fabric 将该位作为有效载荷传递给 PCIe 接口。对于所有其他虚拟通道，此位保留，但建议为这些事务设置该位（由于不同的虚拟通道，它们将能够通过 posted 写入）。</p><hr><p><strong><a id=reqblocklevel>ReqBlockLevel</a></strong></p><p>指示此请求在同一虚拟通道内阻塞在早期请求后面所需的匹配级别。</p><p>此字段的编码如 <em><a href="#表 17 ReqBlockLevel 编码">表 17 ReqBlockLevel 编码</a></em> 所示。</p><p><strong><a id="表 17 reqblocklevel 编码">表 17 ReqBlockLevel 编码</a></strong></p><table><thead><tr><th>ReqBlockLevel</th><th>阻塞类型</th><th>对于非 Barrier 命令</th><th>对于 Fence 和 Flush</th></tr></thead><tbody><tr><td>00b</td><td>地址</td><td>请求仅在与同一端口对同一地址发出的写入上阻塞</td><td>无效</td></tr><tr><td>01b</td><td>流</td><td>请求在与同一端口、ReqUnitID 和 ReqStreamID 发出的任何写入上阻塞</td><td>应用于来自同一端口且匹配 ReqUnitID 和 ReqStreamID 的请求</td></tr><tr><td>10b</td><td>unit</td><td>请求在与同一端口和 ReqUnitID 发出的任何写入上阻塞</td><td>应用于来自同一端口且匹配 ReqUnitID 的请求</td></tr><tr><td>11b</td><td>端口</td><td>请求在来自同一端口的任何写入上阻塞</td><td>应用于来自同一端口的所有请求</td></tr></tbody></table><hr><p><strong><a id=reqrsppasspw>ReqRspPassPW</a></strong></p><p>当 ReqVC 指定一个 non-posted 虚拟通道（在上行或下行方向）时，ReqRspPassPW 指定（当为 0 时）对此请求的响应不得通过与响应流向相同方向的 posted 写入。有关更多信息，请参见 Ordering。</p><p>此位对于所有其他虚拟通道是保留的，但建议为这些事务设置该位（因为它们的响应将能够通过 posted 写入）。</p><hr><p><strong><a id=reqvc>ReqVC</a></strong></p><p>指定请求的虚拟通道。参见 <em><a href="#3.3 虚拟通道部分">3.3 虚拟通道部分</a></em>。</p><hr><p><strong><a id=reqchain>ReqChain</a></strong></p><p>可选字段，提供一个提示，指示应将同一 VC 中的后续请求分组在一起以进行路由。</p><hr><p><strong><a id=reqstwayid>ReqStWayId</a> <a id=reqstupdate>ReqStUpdate</a> <a id=reqstinvalidate>ReqStInvalidate</a></strong></p><p>在为了限制探测而拥有 Originator 缓存的“影子标签”的实现中，Fields ReqStWayId、ReqStUpdate、ReqStInvalidate 共同指示 Originator 的缓存和替换算法。
然后，Completer 更新影子标签，以维护所有正在一致性缓存的缓存行的准确状态。这些影子标签用于将探测限制为仅针对已知在 Originator 缓存中的缓存行。尽管这些影子标签应该准确地限制探测，但 Originator 不得将接收到未命中缓存的探测视为错误。</p><p>实现注意：要求 Originator 和 Completer 共享相同的算法，该算法基于 ReqAddr 选择索引，因为 SDP 上未指定索引。</p><p><em><a href="#表 18 缓存Tag跟踪">表 18 缓存Tag跟踪</a></em> 指定了这些位的含义以及它们如何与此事务引起的预期缓存分配或失效相关。</p><p>对于所有非一致性命令（RdSized<em>NC、WrSized</em>NC、AtomicNC*），这些字段是保留的，且 ReqStUpdate 和 ReqStInvalidate 应为 00b。</p><p>**<a id="表 18 缓存tag跟踪">表 18 缓存Tag跟踪</a> **</p><table><thead><tr><th>命令</th><th>ReqStUpdate</th><th>ReqStInvalidate</th><th>含义/结果</th></tr></thead><tbody><tr><td>RdBlk*、ChgToX*、ValBlk</td><td>0</td><td>1</td><td>Originator 打算在由 ReqStWayId 指定的方式以非一致性方式缓存该行。Completer 被指示在适当的索引处使任何先前的影子标签无效。Originator 不需要对此地址进行未来的探测，因为它没有一致性副本。</td></tr><tr><td></td><td>1</td><td>0</td><td>Originator 打算在由 ReqStWayId 指定的方式以一致性方式缓存该行。Completer 被指示在适当的索引处使用此新地址更新影子标签。Originator 将需要对此地址进行未来的探测。</td></tr><tr><td>VicBlk*</td><td>1</td><td>X</td><td>Victim 上的Cache State转换在 ReqAttr 中指定。</td></tr><tr><td>WrSized、WrSizedFull、WrSizedFullZero、WrSizedFullComp、Atomic、AtomicNR</td><td>0</td><td>0</td><td>作为此写入的一部分，Originator 无意缓存该行，且之前未在缓存中存在该行。Completer 不对影子标签进行更新。ReqStWayId 保留。由于 Originator 没有一致性副本，因此不需要对此地址进行未来的探测。</td></tr><tr><td></td><td>0</td><td>1</td><td>作为此写入的一部分，Originator 已使缓存行的当前副本无效。Completer 被指示在适当的索引处使任何先前的影子标签无效。由于 Originator 没有副本，因此不需要对此地址进行未来的探测。该行的方式未由 ReqStWayId 指定，后者保留。Completer 使用适当索引处的所有方式的正常搜索来使任何先前的影子标签无效。</td></tr><tr><td></td><td>1</td><td>1</td><td>作为此写入的一部分，Originator 已在由 ReqStWayId 指定的方式以一致性方式缓存该行。Completer 被指示在适当的索引处使用此新地址更新影子标签。Originator 将需要对此地址进行未来的探测。</td></tr><tr><td>所有其他命令</td><td>0</td><td>0</td><td>不执行影子标签更新。ReqStWayId 保留。</td></tr></tbody></table><p>注意：</p><p>1）ReqStUpdate 和 ReqStInvalidate 的其他组合是保留的。</p><hr><p><strong><a id=reqcachehint（reqnoalloc）>ReqCacheHint（ReqNoAlloc）</a></strong></p><p>此字段为读取、写入、Victim 和原子操作提供时间性提示。当 ReqIO=1 或 ReqSpecialAddr=1 时，此字段保留。</p><p><strong><a id="表 19 reqcachehint 用法">表 19 ReqCacheHint 用法</a></strong></p><table><thead><tr><th>值</th><th>含义</th></tr></thead><tbody><tr><td>00b</td><td>常规时间性重用（RT）</td></tr><tr><td>01b</td><td>低（非时间性）重用（NT）</td></tr><tr><td>10b</td><td>高时间性重用（HT）</td></tr><tr><td>11b</td><td>读取：不分配，最后一次使用（丢弃脏数据）。<br>写入：直达写入。<br>原子操作：直达写入，最后一次使用。</td></tr></tbody></table><p>在先前的规范中，ReqCacheHint 被命名为 ReqNoAlloc，且为单个位。通过设置 ReqCacheHint[1]=0b 且 ReqCacheHint[0]=ReqNoAlloc，可以将 ReqNoAlloc 扩展为 ReqCacheHint。</p><hr><p><strong><a id=reqcompmode>ReqCompMode</a></strong></p><p>此字段为Metadata Compression指定请求的压缩模式。</p><p>**<a id="表 20 reqcompmode 用法">表 20 ReqCompMode 用法</a> **</p><table><thead><tr><th>命令</th><th>值</th><th>含义</th></tr></thead><tbody><tr><td>Atomic* 和 WrSized*（除 WrSizedFullComp）</td><td>00b</td><td>绕过压缩。对于写入，ReqAttr[7:6] 必须为 00b，表示数据未压缩。</td></tr><tr><td></td><td>01b</td><td>启用压缩，如 ReqAttr[7:6] 所示。Completer 也可以（可选地）压缩数据。</td></tr><tr><td></td><td>10b</td><td>启用压缩，如 ReqAttr[7:6] 所示，但禁用任何额外的 Completer 压缩。</td></tr><tr><td></td><td>11b</td><td>保留</td></tr><tr><td>RdSized*、RdBlk* 和 SpecPrefCmd</td><td>00b</td><td>绕过压缩。数据将以未压缩形式返回，RdRspDataCompMeta 指定未压缩数据。Completer 也可以绕过获取与该块关联的压缩元数据（数据已知为未压缩）。</td></tr><tr><td></td><td>01b</td><td>读取压缩数据。数据可能以压缩或未压缩形式返回，如 RdRspDataCompMeta 中的元数据所示。当压缩时，返回的数据节拍数可能小于 ReqLen 指定的块大小。</td></tr><tr><td></td><td>10b</td><td>读取未压缩数据。数据将以未压缩形式返回，RdRspDataCompMeta 指定未压缩数据。Completer 使用压缩元数据来解压数据块。</td></tr><tr><td></td><td>11b</td><td>保留</td></tr><tr><td>WrNoDataNC</td><td>11b</td><td>强制解压缩。Completer 将使用压缩元数据来确定数据块是否被压缩。如果被压缩，Completer 将解压数据。</td></tr><tr><td></td><td>00b、01b、11b</td><td>保留</td></tr><tr><td>所有其他命令</td><td>n/a</td><td>保留</td></tr></tbody></table><hr><p><strong><a id=reqspecdatafetch>ReqSpecDataFetch</a></strong></p><p>此字段向 Completer 提供一个提示，指示在压缩元数据的内容已知之前，是否应预取内存块。此字段对非缓存读取、写入、原子操作和缓存读取有效。对于所有其他命令，此字段保留（00b）。</p><p>**<a id="表 21 reqspecdatafetch 用法">表 21 ReqSpecDataFetch 用法</a> **</p><table><thead><tr><th>值</th><th>含义</th></tr></thead><tbody><tr><td>00b</td><td>建议根据带宽使用情况进行预取。Originator 指示应预取数据块，但仅当 Completer 当前未受到带宽限制时。</td></tr><tr><td>01b</td><td>不建议预取。Originator 指示数据块可能被压缩，首先应获取元数据以确定压缩数据的实际长度。</td></tr><tr><td>10b</td><td>建议预取。Originator 指示应预取数据块（可能是未压缩数据）。</td></tr><tr><td>11b</td><td>保留</td></tr></tbody></table><hr><p><strong><a id=reqvld>ReqVld</a></strong></p><p>此信号指示 Originator 在此通道上提供了有效信息。</p><hr><p><strong><a id=reqcredittype>ReqCreditType</a></strong></p><p>当 ReqCreditType = 1 时，正在释放的 credit 是一个池 credit，可用于任何虚拟通道中的请求。
当 ReqCreditType = 0 时，正在释放的 credit 是特定 VC 的 credit。有关 credits 和流控制的更多信息，请参见 <em><a href="#3.4 通道流控制">3.4 通道流控制</a></em> 。</p><hr><p><strong><a id=reqcreditvc>ReqCreditVC</a></strong></p><p>指定正在释放的 credit 的虚拟通道。仅当 ReqCreditType = 0 时有效。</p><hr><p><strong><a id=reqcreditvld>ReqCreditVld</a></strong></p><p>当 ReqCreditVld 断言时，端口（或在 Completer 端口，Completer）正在释放一个或多个 credits。
当实现时，ReqCreditCnt、ReqCreditType、ReqCreditVC 和 ReqCreditChanAB 提供有关正在释放的 credits 的类型和数量的信息。
当未实现任何可选的 ReqCredit* 字段时，每当在活动时钟边沿断言此信号时，都会释放一个 Originator 请求通道 credit。</p><hr><p><strong><a id=requser>ReqUser</a></strong></p><p>可选信号，可用于任何目的。信息流必须与通道的方向相同。ReqUser 位不会自动复制到响应中。</p><h5 id=a-id227-read-response-channel227-read-response-channela><a id="2.2.7 Read Response Channel">2.2.7 Read Response Channel</a></h5><p>Read Response Channel(s) 为特定的读请求提供读取请求的 meta-data、完成状态和响应数据。
此外，如果实现了 Completer Fatal Error Notification Feature 且未实现 Write Response Channel，
Completer 还可能发送一个未关联到任何未完成请求的 RdRspStatus=SYSFATALERR 的非请求读响应。
有关更多信息，请参阅*<a href="#3.12.4 using response channels for unsolicited fatal errors">3.12.4 sing Response Channels for Unsolicited Fatal Errors</a>*。</p><p>Read Response Channel 基于特定的预告间隔，在随后的时钟周期开始提供请求的数据。
请参阅 <em><a href="#3.2 Data Transfer">3.2 Data Transfer</a></em></p><p>数据在一个或多个数据传输周期（也称为 beats）中通过 RdRspData Field 返回。
响应根据 RdRspUnitID 和 RdRspTag Fields 中的信息与引发它的请求进行匹配。
对于一个读响应要对应于一个读请求，响应的 RdRspUnitID 必须与请求的 UnitID 匹配，RdRspTag 必须与 ReqTag 匹配。</p><p><em><a href="#表 22 read response channel signals">表 22 Read Response Channel Signals</a></em>
列出了构成 Read Response Channel 的信号。所有的信号名称都采用单通道接口的命名约定。</p><p>标记为 <strong>Required</strong> 的列指示了哪个可选 feature 要求实现该 field。
“Yes” 表示所有实现都需要该 feature。
如果 Originator 未实现 Read Response feature 且未发出任何生成读响应的命令（仅写接口），
则整个 Read Response Channel 是可选的。</p><p>标记为 <strong>Driver</strong> 的列指示了在 Originator port 中 field 内的信息流方向。</p><p><a id="表 22 Read Response Channel Signals">表 22 Read Response Channel Signals</a></p><table><thead><tr><th>Name</th><th>Size</th><th>Driver</th><th>Description</th><th>Required</th></tr></thead><tbody><tr><td><em><a href=#rdrsptag>RdRspTag</a></em></td><td>N<sub>rt</sub></td><td>Port</td><td>Read response tag。<br>此 field 包含发起事务的请求的 tag。<br>此 field 的宽度等于请求 tag 的宽度。</td><td>Yes</td></tr><tr><td><em><a href=#rdrspunitid>RdRspUnitID</a></em></td><td>N<sub>ui</sub></td><td>Port</td><td>Read response UnitID。<br>此 field 指定请求中的 ReqUnitID。<br>由 Originator 用于将此响应与发起它的unit进行匹配。<br>由于 tag 值是按unit分配的，UnitID 限定了 tag 值。此 field 的宽度等于请求 UnitID（Nui）的宽度。</td><td>Yes，除了当 Completer 的 CS 展平了 tag 空间时</td></tr><tr><td><em><a href=#rdrspvc>RdRspVC</a></em></td><td>N<sub>rvc</sub></td><td>Port</td><td>Read response Virtual Channel。<br>指定响应的 Virtual Channel。<br>与发起请求的 Virtual Channel 匹配。</td><td>Virtual Channel Support</td></tr><tr><td><em><a href=#rdrsppasspw>RdRspPassPW</a></em></td><td>1</td><td>Port</td><td>Read response pass posted write。<br>确定读响应是否可以通过先前的 posted 写入。<br>- <strong>1</strong>：响应可以通过来自同一源到其目的地的 posted Virtual Channel 中的先前写入。<br>- <strong>0</strong>：响应不得通过同一方向流动的 posted 写入。<br>此 field 的值通常基于正在完成的请求的 ReqRspPassPW。在 non-posted 之外的任何 Virtual Channel 中的响应，此值没有意义。</td><td>Posted write ordering feature</td></tr><tr><td><em><a href=#rdrspparity>RdRspParity</a></em></td><td>1</td><td>Port</td><td>Read Response Parity。<br>维护除 RdRspVld、RdRspDataVld、RdRspData*、RdRspClkEn_m1、RdRspDataClkEn_m1 和 RdRspCredit* 之外的所有由 Port 驱动（或在 Completer 端口由 Completer 驱动）的 Read Response Channel fields 的偶校验。</td><td>Enhanced RAS V1 feature</td></tr><tr><td><em><a href=#rdrspdelay>RdRspDelay</a></em></td><td>1</td><td>Port</td><td>Read response data lag。<br>指示应用于此响应的两种预告间隔 N<sub>lag</sub> 中的哪一个。<br>- <strong>0</strong>：N<sub>lag</sub> = N<sub>short_lag</sub><br>- <strong>1</strong>：N<sub>lag</sub> = N<sub>long_lag</sub><br>有关更多细节，请参阅 <em><a href="#3.2 Data Transfer">3.2 Data Transfer</a></em>。<br>如果未实现 Variable Heads-Up feature，响应和数据之间的滞后固定为 N<sub>short_lag</sub>。</td><td>Variable Heads-Up feature</td></tr><tr><td><em><a href=#rdrspstatus>RdRspStatus</a></em></td><td>N<sub>rdstat</sub></td><td>Port</td><td>Read response status。<br>此 field 指示读请求的状态。<br>RdRspStatus 在响应的所有 beats 中必须相同，包括任何 RETRANSMIT。<br>有关此 field 的更多信息，请参见下文的 <em><a href=#rdrspstatus>RdRspStatus</a></em> 。<br>未支持所有错误编码的端口可以通过省略高阶位来缩小此 field 的宽度。</td><td>Yes</td></tr><tr><td><em><a href=#rdrspoffset>RdRspOffset</a></em></td><td>N<sub>rdoff</sub></td><td>Port</td><td>Read response offset。<br>指示将在未来 N<sub>lag</sub> 个时钟周期后返回哪个数据 beat。<br>有关此 field 的更多信息，请参见下文的 <em><a href=#rdrspoffset>RdRspOffset</a></em> 。</td><td>Yes</td></tr><tr><td><em><a href=#rdrsplast>RdRspLast</a></em></td><td>1</td><td>Port</td><td>Read response last。<br>此信号与数据传输的最后一个 beat 关联的响应一起断言。<br>有关更多细节，请参阅 <em><a href="#3.2 Data Transfer">3.2 Data Transfer</a></em> 。</td><td>Yes</td></tr><tr><td><em><a href=#rdrspsrcdata>RdRspSrcData</a></em></td><td>6</td><td>Port</td><td>提供数据源的上下文。<br>此 field 仅对没有错误的响应有效。<br><br>RdRspSrcData[5:4] – <strong>Responder Type</strong> 区分响应是从系统中的另一个缓存返回的，以及该缓存的本地性。<br>- <strong>00</strong>：数据从设备/内存返回。<br>- <strong>01</strong>：数据是来自与此 Originator 相同 NUMA 节点内的缓存命中的结果。<br>- <strong>10</strong>：数据是来自与此 Originator 相同封装（处理器）但不同 NUMA 节点内的缓存命中的结果。<br>- <strong>11</strong>：数据是来自与此 Originator 不同封装（处理器）内的缓存命中的结果。<br><br>RdRspSrcData[3:2] – <strong>Memory Locality</strong> 指定请求目标（内存通道、IO 设备）的本地性。<br>- <strong>00</strong>：请求地址的目标在与此 Originator 相同的 NUMA 节点内。<br>- <strong>01</strong>：请求地址的目标不在与此 Originator 相同的 NUMA 节点内，但在相同的封装（处理器）内。<br>- <strong>10</strong>：请求地址的目标在与此 Originator 不同的封装（处理器）内。<br>- <strong>11</strong>：未确定。当目标未参与访问（由于缓存命中）或请求地址或 Originator 的 NUMA 本地性不精确时，可以使用此编码。<br><br><strong>注意</strong>：IO 设备也可能具有本地性，如果地址在与 Originator 相同的 IO-NUMA 节点内，可能会使用 RdRspSrcData[3:2]=00b。<br><br>RdRspSrcData[1:0] – <strong>Memory Type</strong> 指定请求目标（内存通道、IO 设备）的类型。<br>- <strong>00</strong>：快速存储<br>- <strong>01</strong>：慢速存储<br>- <strong>10</strong>：IO<br>- <strong>11</strong>：保留<br><br><strong>注意</strong>：“快速”和“慢速”存储的定义超出了本规范的范围。快速存储可能指 DRAM，而慢速存储可能指 NVDIMM 或外部附加设备。</td><td>Data Source feature</td></tr><tr><td><em><a href=#rdrspvld>RdRspVld</a></em></td><td>1</td><td>Port</td><td>Read response valid。<br>当未实现 Heads-Up feature 时，此信号指示端口（或 Completer）在此通道上提供了有效信息。<br>当实现了 Heads-Up feature 时，Read Response Channel 被分为两个子通道（响应和数据子通道），此信号指示端口（或 Completer）在响应子通道上提供了有效信息（除 RdRspDataVld、RdRspData、RdRspDataParity、RdRspDataStatus、RdRspDataStatusParity 和 RdRspDataUser 之外的所有 fields）。</td><td>Yes</td></tr><tr><td><em><a href=#rdrspclken_m1>RdRspClkEn_m1</a></em></td><td>1</td><td>Port</td><td>Read response clock enable。<br>RdRspClkEn_m1 必须在 RdRspVld 断言前一个时钟周期断言。</td><td>Low-Power Signaling feature</td></tr><tr><td><em><a href=#rdrspuser>RdRspUser</a></em></td><td>—</td><td>Port</td><td>User-defined field。<br>如果实现，信息必须以与 Read Response Channel 相同的方向和与读响应相同的时序流动。</td><td>User-defined</td></tr><tr><td><strong>Data Fields</strong>（当实现了 Heads-Up feature 时可能有滞后）</td><td></td><td></td><td></td><td></td></tr><tr><td><em><a href=#rdrspdata>RdRspData</a></em></td><td>N<sub>rd</sub></td><td>Port</td><td>Read response data。<br>如果读取成功，此 field 携带请求的数据。数据块的传输可能需要多个时钟周期。<br>有关此 field 的更多细节，请参见下文的 <em><a href=#rdrspdata>RdRspData</a></em> 。<br>当实现了 Heads-Up feature 时，此 field（以及 RdRspDataParity、RdRspDataStatus、RdRspDataStatusParity 和 RdRspDataUser）可能滞后于此通道的其他 fields。<br>如果未实现 Heads-Up feature，这些 fields 由 RdRspVld 限定；<br>如果实现了 Heads-Up feature，这些 fields 由 RdRspDataVld 限定。<br>有关更多细节，请参阅 <em><a href="#3.2 Data Transfer">3.2 Data Transfer</a></em> 。</td><td>Yes</td></tr><tr><td><em><a href=#rdrspdataparity>RdRspDataParity</a></em></td><td>N<sub>rd/64</sub></td><td>Port</td><td>Read Response Data Parity。<br>RdRspDataParity 中的每个位为 RdRspData field 的 64 位提供偶校验错误保护。<br>除了当 RdRspDataStatus 为 NODATA 时，RdRspDataParity[i] 和 RdRspData[((i+1)<em>64-1):(i</em>64)] 中设定的位数总是偶数。<br>端口或 Completer 必须提供偶校验，包括当读取数据由于命令的长度或地址、RETRANSMIT 和 DATERR 而被屏蔽的情况。<br><br>每 64 位提供一位。如果 RdRspData field 宽度除以 64 不是整数，应为剩余的（Nrd MOD 64）位提供单独的偶校验位。<br><br>此 field 与 RdRspData 具有相同的时序发送。</td><td>Yes，除非 RdRspDataUser 位实现了更高级的保护，如 ECC</td></tr><tr><td><em><a href=#rdrspdatastatus>RdRspDataStatus</a></em></td><td>2</td><td>Port</td><td>Read response data status。<br>此 field 指示读传输的状态，并与 RdRspData 具有相同的时序发送。<br>有关此 field 的编码，请参见下文的 <em><a href=#rdrspdatastatus>RdRspDataStatus</a></em> 。<br>建议当未断言 RdRspVld（或在 Heads-Up feature 下未断言 RdRspDataVld）时忽略此 field。</td><td>Yes</td></tr><tr><td><em><a href=#rdrspdatastatusparity>RdRspDataStatusParity</a></em></td><td>1</td><td>Port</td><td>Read response data status parity。维护 RdRspDataStatus field 的偶校验。此 field 与 RdRspData 具有相同的时序发送。</td><td>Enhanced RAS V2 feature</td></tr><tr><td><em><a href=#rdrspdatacompmeta>RdRspDataCompMeta</a></em></td><td>N<sub>md</sub></td><td>Port</td><td>Read response compression meta-data。<br>如果此 field（除奇偶校验外）全为 1，则数据未压缩。否则，此 field 指示如何解压 RdRspData。<br>参见 <em><a href="#3.2.3 MetaData Compression">3.2.3 MetaData Compression</a></em> 。<br>此 field 还包括一个奇偶校验位，除了通常被视为 meta-data 的内容。当 meta-data 的大小为“n”位时，此 field 为“n+1”位（Nmd 比 meta-data 大小多一位）。<br>实际的 meta-data 位于 RdRspDataCompMeta[Nmd-2:0] 中。RdRspDataCompMeta[Nmd-1] 是一个奇偶校验位，维护整个 RdRspDataCompMeta 的偶校验。</td><td>MetaData Compression feature</td></tr><tr><td><em><a href=#rdrspdatauser>RdRspDataUser</a></em></td><td>—</td><td>Port</td><td>User-defined field。<br>如果实现，信息必须以与读响应数据相同的方向和与 RdRspData 相同的时序流动。<br><br><strong>注意</strong>：RdRspDataParity 不覆盖 RdRspDataUser。任何必要的 RdRspDataUser 的奇偶校验应包含在 RdRspDataUser 位本身。</td><td>User-defined</td></tr><tr><td><em><a href=#rdrspdatavld>RdRspDataVld</a></em></td><td>1</td><td>Port</td><td>Read response data valid。<br>当实现了 Heads-Up feature 时，Read Response Channel 被分为两个子通道（响应和数据子通道）。此信号指示端口（或 Completer）在数据子通道上提供了有效信息（RdRspData、RdRspDataParity、RdRspDataStatus、RdRspDataStatusParity 和 RdRspDataUser）。有关更多细节，请参阅 <em><a href="#3.2.7 read response data lag and the variable heads-up feature">3.2.7 Read Response Data Lag and the Variable Heads-Up Feature</a></em> 。</td><td>Heads-Up feature</td></tr><tr><td><em><a href=#rdrspdataclken_m1>RdRspDataClkEn_m1</a></em></td><td>1</td><td>Port</td><td>Read response data clock enable。<br>RdRspDataClkEn_m1 必须在 RdRspDataVld 断言前一个时钟周期断言。</td><td>Low-Power Signaling feature 和 Heads-Up feature</td></tr><tr><td><strong>Credit Fields</strong></td><td></td><td></td><td></td><td></td></tr><tr><td><em><a href=#rdrspcredittype>RdRspCreditType</a></em></td><td>1</td><td>Originator</td><td>Read response credit type。<br>当置位时，正在释放的 credit 是一个池 credit。当清零时，credit 用于由 RdRspCreditVC 字段指示的 Virtual Channel 中的读响应。</td><td>Virtual Channel Support</td></tr><tr><td><em><a href=#rdrspcreditvc>RdRspCreditVC</a></em></td><td>N<sub>rvc</sub></td><td>Originator</td><td>Read response credit Virtual Channel。<br>正在释放的 credit 的 Virtual Channel。仅当 RdRspCreditType 为 0 时有效。</td><td>Virtual Channel Support</td></tr><tr><td><em><a href=#rdrspcreditparity>RdRspCreditParity</a></em></td><td>1</td><td>Originator</td><td>Read response credit parity。<br>维护除 RdRspCreditVld、RdRspCreditClkEn_m1 和 RdRspCreditRdy 之外的 RdRspCredit* fields 的偶校验。</td><td>Enhanced RAS V3 feature</td></tr><tr><td><em><a href=#rdrspcreditcnt>RdRspCreditCnt</a></em></td><td>N<sub>cc</sub>[1]</td><td>Originator</td><td>返回的 credit 数量的零原点 field。</td><td>Credit Count feature</td></tr><tr><td><em><a href=#rdrspcreditvld>RdRspCreditVld</a></em></td><td>1</td><td>Originator</td><td>Read response credit valid。<br>Originator（或在 Completer 端口由 port）在 credit 释放子通道上提供的信息是有效的。</td><td>Yes</td></tr><tr><td><em><a href=#rdrspcreditclken_m1>RdRspCreditClkEn_m1</a></em></td><td>1</td><td>Originator</td><td>Read response credit clock enable。<br>RdRspCreditClkEn_m1 必须在 RdRspCreditVld 断言前一个时钟周期断言。</td><td>Low-Power Signaling feature</td></tr><tr><td><em><a href=#rdrspcreditrdy>RdRspCreditRdy</a></em></td><td>1</td><td>Port 或 pervasive logic</td><td>Read response credit ready。<br>此信号用于为时钟同步目的调节跨接口的读响应 credit 信息流。有关 *Rdy / *Vld 握手的更多信息，请参见 <em><a href=#2.4信号需求>2.4信号需求</a></em> 。</td><td>Yes</td></tr></tbody></table><p><strong>注意：</strong></p><ol><li><p>在 Completer 端口由 Completer 设备驱动；在 Originator 端口不支持。</p></li><li><p>在 Completer 端口由 port 驱动；在 Originator 端口不支持。</p></li></ol><p><strong><a id=rdrspdata>RdRspData</a></strong></p><p>此 Field 的大小依赖于实现，但必须是 8 的整数倍且不大于系统缓存行大小。
此 Field 相对于读响应滞后 N<sub>lag</sub> 个周期。更多细节请参见 <em><a href="#3.2 Data Transfer">3.2 Data Transfer</a></em>。</p><hr><p><strong><a id=rdrspstatus>RdRspStatus</a></strong></p><p>RdRspStatus 同时提供读响应的成功/失败指示，此外还可能指示缓存状态。</p><p>RdRspStatus 的宽度可以是 3、4 或 6 位，具体取决于实现并在端口参数化（N<sub>rdstat</sub>）中指定。
所需的宽度取决于发出的命令类型和端口类型：</p><ul><li>如果端口可能发出缓存读取或缓存更新请求（RdBlk*、ChgToX* 等），则 N<sub>rdstat</sub> 必须为六位。<ul><li>仅发出 RdBlkS 作为唯一缓存读取且不发出任何缓存更新请求的端口不受此规则限制。</li></ul></li><li>如果端口使用 AddrXlateRd 命令，或者端口具有可能传达完成超时或配置请求重试的 PCI 附件，则 N<sub>rdstat</sub> 必须至少为四位。</li><li>所有其他实现要求 N<sub>rdstat</sub> 至少为三位。</li></ul><p>总体的读响应完成状态由 RdRspStatus[3:0] 提供，同时也指示任何失败的原因。
然而，当发出缓存读取命令时，RdRspStatus[5:3] 用于编码缓存状态，而 RdRspStatus[2:0] 指示读响应完成状态。
当 RdRspStatus[3] 编码为缓存状态时，只有 RdRspStatus[2:0] 指示读响应完成失败，并且应将 <em><a href="#表 23">表 23</a></em> 解释为 RdRspStatus[3] 为零。</p><p>RdRspStatus[3:0] 的编码如表 23 所示。</p><hr><p><strong><em><a href=#表23>表23</a></em> RdRspStatus[3:0] 编码</strong></p><table><thead><tr><th>RdRspStatus[3:0]</th><th>Response</th><th>Comment</th></tr></thead><tbody><tr><td>0000b</td><td>OKAY（正常完成）</td><td>事务正常完成。</td></tr><tr><td>0001b</td><td>（仅限 AddrXlateRd）PERMISSION_VIOLATION</td><td>对于 AddrXlateRd，由于权限违规，无法执行翻译。此编码对所有其他命令保留。<br><br><strong>架构注意</strong>：此编码先前保留用于“Monitor Locks”，现已弃用。</td></tr><tr><td>0010b</td><td>SLVERR（目标终止）</td><td>指示事务的目标端（即 I/O 设备或内存设备）在处理事务时发生错误或无法完成事务。如果再次执行该事务，此错误可能会持续存在，也可能不会持续存在。此错误响应与 PCI 定义的“目标终止”一致。</td></tr><tr><td>0011b</td><td>DECERR（解码错误）</td><td>指示一种地址解码错误，例如无效地址或与命令类型不匹配的地址（例如，对解码为 I/O 设备的地址执行某些可缓存事务）。此错误通常是持久性的——如果在没有任何配置更改的情况下再次执行具有相同地址的相同事务，将再次出现 DECERR。</td></tr><tr><td>0100b</td><td>EARLY（提前响应）</td><td>参见后续讨论。</td></tr><tr><td>0101b</td><td>OKAY_NODATA（正常完成但无数据）</td><td>事务正常完成，但未提供数据。此编码必须与 RdRspDataStatus=NODATA 一起使用。参见 <em><a href="#3.2.3 read response with nodata">3.2.3 Read Response with NODATA</a></em> 。</td></tr><tr><td>0110b</td><td>PROTVIOL（保护违规）</td><td>指示某些安全或保护检查导致事务被中止。此错误通常是持久性的——如果在没有任何配置更改的情况下再次执行具有相同地址的相同事务，将再次出现 PROTVIOL。</td></tr><tr><td>0111b</td><td>TRANSERR（事务错误）</td><td>指示事务在目标端之间的一层或多层发生错误（因为目标端的错误通常会返回 SLVERR）。此错误可能发生在 Completer-Proxy、中间件、任何被探测的缓存或实际目标端之前的任何集线器或翻译点。如果再次执行该事务，此错误可能会持续存在，也可能不会持续存在。</td></tr><tr><td>1000b</td><td>（仅限 RdSized*）CMPTO（完成超时）</td><td>仅对 RdSized* 命令有效。</td></tr><tr><td>1001b</td><td>（仅限 AddrXlateRd）UNTRANSLATED</td><td>对于 AddrXlateRd，由于未指定的原因无法执行翻译，可能会重试。此编码对所有其他命令保留。</td></tr><tr><td>1010b</td><td>（仅限 AddrXlateRd）TRANSLATION_FAULT</td><td>对于 AddrXlateRd，由于地址翻译错误，无法执行翻译。此编码对所有其他命令保留。</td></tr><tr><td>1011b</td><td>保留</td><td></td></tr><tr><td>1100b</td><td>（仅限 RdSized*）CRS（配置请求重试）</td><td>仅对 RdSized* 命令有效。</td></tr><tr><td>1101b</td><td>SYSFATALERR（系统致命错误）</td><td>一个非请求（未关联到未完成请求）的系统致命错误指示。有关更多信息，请参阅 <em><a href="#3.12.4 using response channels for unsolicited fatal errors">3.12.4 Using Response Channels for Unsolicited Fatal Errors</a></em> 。RdRspTag 可用于编码有关致命错误的类型或原因的更多信息。如果未实现 Completer Fatal Error Notification Feature 或已实现任何写响应通道，则此编码保留（未使用）。如果已实现写响应通道，实现必须使用写响应通道而不是读响应通道来处理非请求的致命错误。</td></tr><tr><td>1110b</td><td>保留</td><td></td></tr><tr><td>1111b</td><td>保留</td><td></td></tr></tbody></table><p><strong>实现注意</strong>：CMPTO 和 CRS 仅保留用于连接到 PCI 的 SDP 端口。SOC-15 数据 Fabric 不返回 CMPTO 或 CRS。</p><p><strong>EARLY</strong> 表示请求数据的系统范围缓存行的合并状态尚未确定，返回的数据可能是过时的。
随后将跟随第二个 Read Response，带有新的数据或无数据（NODATA），以更新合并的系统状态信息。
对 <strong>EARLY</strong> 读响应特性的支持是可选的，originator 并不需要支持它。</p><p>对于未以错误响应（RdRspStatus[2:0] = OKAY 或 OKAY_NODATA）结束的缓存读取或缓存更新命令（RdBlk*、ChgToX*），RdRspStatus[3] = PassDirty，
RdRspStatus[5:4] 返回请求缓存行的合并系统状态，编码如 <em><a href="#表 24">表 24</a></em> <strong>RdRspStatus[5:3] Encoding</strong> 所示。
除非使用了探测 originator 的命令，否则系统状态不包括 originator 的缓存状态。
对于缓存读取和缓存更新命令以外的任何命令的响应，系统状态和 PassDirty 位没有意义，对于在 RdRspStatus[2:0] 中指示错误的任何响应也是如此。
例如，以保护违规结束的 RdBlkL 并未探测同级缓存。当 RdRspStatus[2:0] 指示错误时，期望 originator 不缓存该行。</p><p>对于非缓存读取命令（RdSized*）和 AddrXlateRd，RdRspStatus[3] 用于编码上述表格中显示的扩展状态（最后 8 行）。
CMPTO 和 CRS 编码仅用于直接连接到 PCI 主桥的端口。</p><p>对于不发出缓存读取或缓存升级命令（非一致性 originators）且未连接到 PCI 主桥的端口，RdRspStatus[5:3] 保留。
对于不发出缓存读取或缓存升级命令（非一致性 originators）且连接到 PCI 主桥的端口，RdRspStatus[5:4] 保留。
建议这些端口使用配置参数 N<sub>rdstat</sub> 仅实例化必要的位。</p><p><strong>表 24 RdRspStatus[5:3] Encoding</strong></p><table><thead><tr><th>RdRspStatus[5:4]</th><th>RdRspStatus[3]</th><th>System State</th><th>Data state</th><th>Notes</th></tr></thead><tbody><tr><td>00b</td><td>0</td><td>I</td><td>Clean</td><td></td></tr><tr><td>00b</td><td>1</td><td>I</td><td>Dirty</td><td></td></tr><tr><td>01b</td><td>0</td><td>S</td><td>Clean</td><td></td></tr><tr><td>01b</td><td>1</td><td>S</td><td>Dirty</td><td></td></tr><tr><td>10b</td><td>0</td><td>X (E, M, D, or Mp)</td><td>Clean</td><td></td></tr><tr><td>10b</td><td>1</td><td>X (E, M, D, or Mp)</td><td>n/a</td><td>此编码仅可能作为 ClnBlkAll 的结果，并可能指示该行在过程中被清理（例如 M->E）。originator 不应依赖 RdRspStatus[3] 指示这一点，也不应依赖探测发生后系统状态未从 E->M 变化。</td></tr><tr><td>11b</td><td>0</td><td>O</td><td>Clean</td><td></td></tr><tr><td>11b</td><td>1</td><td>F</td><td>Clean</td><td></td></tr></tbody></table><hr><p><strong><a id=rdrspdatastatus>RdRspDataStatus</a></strong></p><p>此 field 提供通过 RdRspData field 在端口接口上呈现的数据的信息。
此 field 相对于读响应滞后 N<sub>lag</sub> 个周期（与 RdRspData 同步有效）。
此 field 的编码在 <em><a href="#表 25">表 25</a></em> <strong>RdRspDataStatus Encoding</strong> 中定义。</p><p><strong><a id="表 25">表 25</a> RdRspDataStatus Encoding</strong></p><table><thead><tr><th>RdRspDataStatus</th><th>Transfer Status</th><th>Description</th></tr></thead><tbody><tr><td>00b</td><td>NODATA</td><td>此响应没有关联的有效数据。必须忽略 RdRspData field 的内容。此状态的使用仅限于“Read Response with NODATA”中列出的情况。</td></tr><tr><td>01b</td><td>DATERR</td><td>已知传输的数据存在错误（在其存储或传输中发生了不可纠正的错误）。</td></tr><tr><td>10b</td><td>RETRANSMIT</td><td>当在最后一个 beat 上断言时，表示发生了瞬态错误。数据将被重传。当在其他 beats 上断言时，可能发生了瞬态或数据错误。参见“Read Response Data Retransmission”。对 RETRANSMIT 的支持是可选的，originator 并不需要支持它。</td></tr><tr><td>11b</td><td>VALID</td><td>在 RdRspData field 中呈现的数据在此时钟周期内有效。</td></tr></tbody></table><hr><p><strong><a id=rdrspoffset>RdRspOffset</a></strong></p><p>读取数据在 RdRspData field 中以一个或多个称为 beats 的传输周期返回给 originator。
每个 beat 按照内存中数据的顺序，从 0 开始顺序分配编号，直到 n-1；n 是传输请求数据所需的 beats 总数。
当传输需要多个 beat 时，completer 可以以不同于顺序的顺序返回 beats。此 field 提供与此响应对应的 beat 的编号。</p><p>Beat 0（RdRspOffset = 0）将始终包含请求数据有效载荷的初始（最低地址）字节。
对于 RdSized* 命令，初始地址是读取请求的 ReqAddr field 中提供的值。
对于 RdBlk* 命令，completer 将返回包含请求数据的缓存块。因此，beat 0 的初始（最低地址）是对 ReqAddr 进行系统缓存行大小对齐的值。</p><p>在时钟 x 上返回的 RdRspOffset field 的值是将在未来周期 x + N<sub>lag</sub> 中在 RdRspData* fields 中呈现的 beat 的偏移量。</p><hr><p><strong><a id="read response credit release sub-channel">Read Response Credit Release Sub-channel</a></strong></p><p>当 RdRspCreditVld 断言时，originator（或在 completer 端口上的 port）正在释放一个或多个 credits。
当实现时，RdRspCreditCnt、RdRspCreditType 和 RdRspCreditVC 提供有关正在释放的 credits 的类型和数量的信息。
一个 credit 表示一个读响应数据块的缓冲区空间。
读响应数据块大小依赖于实现，但必须是 RdRspData field 大小的字节数的 2 的幂倍数，且不超过系统缓存行大小。
有关通道流控制的信息，请参见 <em><a href="#3.2 Data Transfer">3.2 Data Transfer</a></em> 。</p><h5 id=a-id228-write-response-channel228-write-response-channela><a id="2.2.8 write response channel">2.2.8 Write Response Channel</a></h5><p>Write Response Channel(s) 向写请求的发起者提供反馈，指示请求在目标处的结果和完成情况。
Responses 根据发起者的 UnitID 和请求 tag 与请求进行匹配。</p><p><em><a href="#表 26 write response channel signals">表 26 Write Response Channel Signals</a></em>
列出了构成 Write Response Channel 的信号。
此外，如果实现了 Completer Fatal Error Notification Feature，
completer 还可能发送一个未关联到任何未完成请求的 WrRspStatus=SYSFATALERR 的非请求写响应。
有关更多信息，请参阅“Using the Write Response Channel for Unsolicited Fatal Errors”。</p><p>标记为 <strong>Required</strong> 的列指示了哪个可选 feature 要求实现该 field。“Yes” 表示所有实现都需要该 feature。如果 originator 未实现 Write Response feature，且未发出任何生成写响应的命令（只读接口），则整个 Write Response Channel 是可选的。</p><p>标记为 <strong>Driver</strong> 的列指示了在 originator port 中 field 内的信息流方向。</p><p><strong>表 26 Write Response Channel Signals</strong></p><table><thead><tr><th>Name</th><th>Size</th><th>Driver</th><th>Description</th><th>Required</th></tr></thead><tbody><tr><td>WrRspTag</td><td>N <sub>rt</sub></td><td>Port</td><td>Write response tag。</br>此 field 包含发起事务的请求的 tag。</br>此 field 的宽度等于请求 tag 的宽度。</br>此 field 也用于 Completer Fatal Error Notification Feature，并可能编码致命错误的类型和/或原因。</td><td>Yes</td></tr><tr><td>WrRspUnitID</td><td>N <sub>ui</sub></td><td>Port</td><td>Write response UnitID。</br>此 field 指定请求中的 ReqUnitID。</br>由 originator 用于将此响应与发起请求的 unit 进行匹配。</br>由于 tag 值是按 unit 分配的，UnitID 限定了 tag 值。</br>此 field 的宽度等于请求 UnitID（N <sub>ui</sub>）的宽度。</td><td>Yes，除了当 completer 的 CS 展平了 tag 空间时</td></tr><tr><td>WrRspStatus</td><td>4</td><td>Port</td><td>Write response status。</br>不实现 WrRspStatus[3]=1 状态编码的 completer 可以将此信号固定为 0。</br>下文的 WrRspStatus 给出了此 field 的编码。</td><td>Yes，除非另有说明</td></tr><tr><td>WrRspVC</td><td>N <sub>rvc</sub></td><td>Port</td><td>Write Response Virtual Channel。</br>响应的 Virtual Channel。</br>与发起请求的 Virtual Channel 匹配。</td><td>Virtual Channel Support</td></tr><tr><td>WrRspPassPW</td><td>1</td><td>Port</td><td>Write response pass posted write。</br>确定写响应是否可以通过先前的 posted 写入。<br><br>- <strong>1</strong>：响应可以通过来自同一源到其目的地的 posted write Virtual Channel 中的先前写入。<br>- <strong>0</strong>：响应不得通过同一方向流动的 posted 写入。<br><br>此 field 的值通常基于正在完成的请求的 ReqRspPassPW。除了 non-posted Virtual Channel 中的响应外，此值没有意义，建议在所有其他 Virtual Channel 中将其设置为 1。</td><td>Posted write ordering feature</td></tr><tr><td>WrRspSrcData</td><td>4</td><td>Port</td><td>提供数据源的上下文。</br>此 field 仅对没有错误的响应有效。<br><br><strong>编码</strong><br><br>WrRspSrcData[3:2] – <strong>Memory Locality</strong> 指定请求目标（内存通道、IO 设备）的本地性。<br>- <strong>00</strong>：请求地址的目标在与此 originator 相同的 NUMA 节点内。<br>- <strong>01</strong>：请求地址的目标不在与此 originator 相同的 NUMA 节点内，但在相同的封装（处理器）内。<br>- <strong>10</strong>：请求地址的目标在与此 originator 不同的封装（处理器）内。<br>- <strong>11</strong>：未确定。当目标未参与访问（由于缓存命中）或请求地址或 originator 的 NUMA 本地性不精确时，可以使用此编码。<br><br><strong>注意</strong>：IO 设备也可能具有本地性，如果地址在与 originator 相同的 IO-NUMA 节点内，可能会使用 WrRspSrcData[3:2]=00b。<br><br>WrRspSrcData[1:0] – <strong>Memory Type</strong> 指定请求目标（内存通道、IO 设备）的类型。<br>- <strong>00</strong>：快速存储<br>- <strong>01</strong>：慢速存储<br>- <strong>10</strong>：IO<br>- <strong>11</strong>：保留<br><br><strong>注意</strong>：“快速”和“慢速”存储的定义超出了本规范的范围。快速存储可能指 DRAM，而慢速存储可能指 NVDIMM 或外部附加设备。</td><td>Data Source Feature</td></tr><tr><td>WrRspParity</td><td>1</td><td>Port</td><td>Write response parity。</br>除 WrRspVld、WrRspClkEn_m1 和 WrRspCreditRdy 之外的所有由 port 驱动（或在 completer port 由 completer 驱动）的 Write Response Channel 信号的偶校验。</td><td>Enhanced RAS V1 feature</td></tr><tr><td>WrRspVld</td><td>1</td><td>Port</td><td>Write response valid。</br>此信号指示 port（或 completer）在此通道上提供了有效的写响应信息。</td><td>Yes</td></tr><tr><td>WrRspClkEn_m1</td><td>1</td><td>Port</td><td>Write response clock enable。</br>WrRspClkEn_m1 必须在 WrRspVld 断言前一个时钟周期断言。</td><td>Low-Power Signaling feature</td></tr><tr><td>WrRspRdy</td><td>1</td><td>Originator 或 pervasive logic</td><td>Write response ready。</br>此信号用于为时钟同步目的调节跨接口的写响应信息流。</br>有关 *Rdy / *Vld 握手的更多信息，请参见 <em><a href="#2.4 信号需求">2.4 信号需求</a></em> 。</td><td>Yes</td></tr><tr><td>WrRspCreditType</td><td>1</td><td>Originator</td><td>- <strong>1</strong>：正在释放的 credit 是一个池 credit，可用于任何 Virtual Channel 中的响应。<br>- <strong>0</strong>：credit 用于特定 Virtual Channel 中的写响应，由 WrRspCreditVC 给出。</td><td>Virtual Channel Support</td></tr><tr><td>WrRspCreditVC</td><td>N <sub>rvc</sub></td><td>Originator</td><td>正在释放的 credit 的 Virtual Channel。</br>仅当 WrRspCreditType = 0 时有效。</td><td>Virtual Channel Support</td></tr><tr><td>WrRspCreditParity</td><td>1</td><td>Originator</td><td>Write response credit parity。</br>除 WrRspCreditVld、WrRspCreditClkEn_m1 和 WrRspCreditRdy 之外的 WrRspCredit* fields 的偶校验。</td><td>Enhanced RAS V3 feature</td></tr><tr><td>WrRspCreditCnt</td><td>N <sub>cc</sub><sup>[2]</sup></td><td>Port</td><td>返回的 credit 数量的零原点 field。</td><td>Credit Count Feature</td></tr><tr><td>WrRspCreditVld</td><td>1</td><td>Originator</td><td>Write response credit valid。</br>originator（或在 completer port 由 port）在 credit 释放子通道上提供的信息是有效的。</td><td>Yes</td></tr><tr><td>WrRspCreditClkEn_m1</td><td>1</td><td>Originator</td><td>Write response credit clock enable。</br>WrRspCreditClkEn_m1 必须在 WrRspCreditVld 断言前一个时钟周期断言。</td><td>Low-Power Signaling feature</td></tr><tr><td>WrRspCreditRdy</td><td>1</td><td>Port 或 pervasive logic</td><td>Write response credit ready。</br>此信号用于为时钟同步目的调节跨接口的写响应 credit 信息流。</br>有关 *Rdy / *Vld 握手的更多信息，请参见 <em><a href="#2.4 信号需求">2.4 信号需求</a></em> 。</td><td>Yes</td></tr><tr><td>WrRspUser</td><td>—</td><td>Port</td><td>用户定义。</br>如果实现，信息必须以与 Write Response Channel 相同的方向流动。</td><td>User-defined</td></tr></tbody></table><p><strong>注意：</strong></p><ol><li><p>在 completer port 由 completer 设备驱动；在 originator port 不支持。</p></li><li><p>在 completer port 由 port 驱动；在 originator port 不支持。</p></li></ol><hr><p><strong>WrRspStatus</strong></p><p><strong>表 27 WrRspStatus Encoding</strong></p><table><thead><tr><th>WrRspStatus[3:0]</th><th>Response</th><th>Comment</th></tr></thead><tbody><tr><td>0000b</td><td>OKAY（正常完成）</td><td>事务正常完成。</td></tr><tr><td>0001b</td><td>保留</td><td><strong>架构注意</strong>：此编码先前保留用于“Monitor Locks”，现已弃用。</td></tr><tr><td>0010b</td><td>SLVERR（目标终止）</td><td>指示事务的目标端（即 I/O 设备或内存设备）在处理事务时发生错误或无法完成事务。</br>如果再次执行该事务，此错误可能会持续存在，也可能不会持续存在。</br>此错误响应与 PCI 定义的“target abort”一致。在执行“posted”写入时，SLVERR 不常见，但合法。</td></tr><tr><td>0011b</td><td>DECERR（解码错误）</td><td>指示一种地址解码错误，例如无效地址或与命令类型不匹配的地址（例如，对解码为 I/O 设备的地址执行某些可缓存事务）。</br>此错误通常是持久性的——如果在没有任何配置更改的情况下再次执行具有相同地址的相同事务，将再次出现 DECERR。</td></tr><tr><td>0100b</td><td>EARLY（提前响应）</td><td>参见后续讨论。</td></tr><tr><td>0101b</td><td>SYSFATALERR（系统致命错误）</td><td>一个非请求（未关联到未完成请求）的系统致命错误指示。</br>有关更多信息，请参阅 <em><a href="#3.12.4 Using the Write Response Channel for Unsolicited Fatal Errors">3.12.4 Using the Write Response Channel for Unsolicited Fatal Errors</a></em> 。</br>WrRspTag 可用于编码有关致命错误的类型或原因的更多信息。</br>如果未实现 Completer Fatal Error Notification Feature，则此编码保留（未使用）。</td></tr><tr><td>0110b</td><td>PROTVIOL（保护违规）</td><td>指示某些安全或保护检查导致事务被中止。此错误通常是持久性的——如果在没有任何配置更改的情况下再次执行具有相同地址的相同事务，将再次出现 PROTVIOL。</td></tr><tr><td>0111b</td><td>TRANSERR（事务错误）</td><td>指示事务在目标端之间的一层或多层发生错误（因为目标端的错误通常会返回 SLVERR）。</br>此错误可能发生在 completer-proxy、中间件、任何被探测的缓存或实际目标端之前的任何集线器或翻译点。</br>如果再次执行该事务，此错误可能会持续存在，也可能不会持续存在。</td></tr><tr><td>1000b</td><td>CMPTO（完成超时）</td><td>仅适用于 sized 写入。<br><br><strong>实现注意</strong>：CMPTO 和 CRS 仅保留用于连接到 PCI 的 SDP 端口。SOC-15 数据 Fabric 不返回 CMPTO 或 CRS。</td></tr><tr><td>1001b</td><td>保留</td><td></td></tr><tr><td>1010b</td><td>保留</td><td></td></tr><tr><td>1011b</td><td>保留</td><td></td></tr><tr><td>1100b</td><td>CRS（配置请求重试）</td><td><strong>实现注意</strong>：CMPTO 和 CRS 仅保留用于连接到 PCI 的 SDP 端口。SOC-15 数据 Fabric 不返回 CMPTO 或 CRS。</td></tr><tr><td>1101b</td><td>保留</td><td></td></tr><tr><td>1110b</td><td>保留</td><td></td></tr><tr><td>1111b</td><td>保留</td><td></td></tr></tbody></table><p>Completer（或 completer proxy）在接收到与此请求关联的所有数据之前，不得生成除 EARLY 之外任何状态的写响应。</p><p>对于 WrSized*，EARLY 响应并不表示最终响应将具有“正常完成”。事务可能会以错误结束，例如由于在探测期间观察到的事务错误。
EARLY 响应仅表示不再需要跟踪它以进行错误报告和/或排序。对 EARLY 写响应特性的支持是可选的，originator 并不需要支持它。</p><p>对于未连接到 PCI 主桥的非一致性 originator port，WrRspStatus[3] 保留。</p><hr><p><strong>Write Response Credit Release Sub-channel</strong></p><p>当 WrRspCreditVld 断言时，originator（或在 completer port 由 port）正在释放一个或多个 credits。
当实现时，WrRspCreditCnt、WrRspCreditType 和 WrRspCreditVC 提供有关正在释放的 credits 的类型和数量的信息。有关通道流控制的信息，请参见 <em><a href="#3.2 数据传输">3.2 数据传输</a></em> 。</p><h5 id=a-id229-response-acknowledge-channel229-response-acknowledge-channela><a id="2.2.9 Response Acknowledge Channel">2.2.9 Response Acknowledge Channel</a></h5><p>Response Acknowledge Channel(s) 被 Originator 用于向 Fabric 指示它已提交了指定事务的结果。
如果未收到没有 EARLY 或 RETRANSMIT 状态的响应的最后一个 beat，则不能发送响应确认。
对于带有 NODATA 的响应，在接收到具有 RdRspStatus=OKAY_NODATA 的读取响应后，任何时候都可以发送响应确认。
Originator 不需要等待 NODATA 的滞后的 RdRspDataStatus。对于发出需要响应确认请求的 Originator，此通道是必需的。Completer 端口不包含此通道。</p><p><em><a href="#表 28 Response Acknowledge Channel Signals">表 28 Response Acknowledge Channel Signals</a></em> 列出了构成 Response Acknowledge Channel 的信号。</p><p><a id="表 28 Response Acknowledge Channel Signals">表 28 Response Acknowledge Channel Signals</a></p><table><thead><tr><th>Name</th><th>Size</th><th>Driver</th><th>Description</th><th>Required</th></tr></thead><tbody><tr><td>AckVld</td><td>1</td><td>Originator</td><td>Acknowledge valid。</br>此信号指示 Originator 提供的事务确认信息是有效的。</td><td>Response Ack feature</td></tr><tr><td>AckClkEn_m1</td><td>1</td><td>Originator</td><td>Acknowledge clock enable。</br>AckClkEn_m1 必须在 AckVld 断言前一个时钟周期被断言。</td><td>Low-Power Signaling feature 和 Response Ack feature</td></tr><tr><td>AckRdy</td><td>1</td><td>Port 或 pervasive logic</td><td>Acknowledge ready。</br>此信号用于为了时钟同步目的调节跨接口的响应确认信息流。有关 *Rdy / *Vld 握手的更多信息，请参见 <em><a href="#2.4 信号需求">2.4 信号需求</a></em> 。</td><td>Response Ack feature</td></tr><tr><td>AckTag</td><td>N <sub>rt</sub></td><td>Originator</td><td>Acknowledge tag。</br>被确认的事务（请求/响应对）的 tag。</td><td>Response Ack feature</td></tr><tr><td>AckUnitID</td><td>N <sub>ui</sub></td><td>Originator</td><td>Acknowledge UnitID。</br>被确认的事务的 Unit ID。</td><td>Response Ack feature</td></tr><tr><td>AckCancel</td><td>1</td><td>Originator</td><td>Acknowledge cancel。</br>如果原始请求是 VicBlk* 或 ChgToX* 请求，请参考命令以获取由于可能的干预 probe 请求而设置 AckCancel 的规则。对所有其他请求类型保留。</td><td>Response Ack feature</td></tr><tr><td>AckParity</td><td>1</td><td>Originator</td><td>Acknowledge parity。</br>除 AckVld、AckClkEn_m1 和 AckCreditRdy 之外的所有 Originator 驱动的 Response Acknowledge Channel fields 的偶校验。</td><td>Enhanced RAS V1 feature</td></tr><tr><td>AckCreditVld</td><td>1</td><td>Port</td><td>Acknowledge credit valid。</br>Originator（或在 Completer 端口的 Port）在 credit release 子通道上提供的信息是有效的。</td><td>Response Ack feature</td></tr><tr><td>AckCreditCnt</td><td>Ncc[3]</td><td>Port</td><td>返回的 credits 数量的零原点 field。</td><td>Credit Count Feature</td></tr><tr><td>AckCreditClkEn_m1</td><td>1</td><td>Port</td><td>Acknowledge credit clock enable。</br>AckCreditClkEn_m1 必须在 AckCreditVld 断言前一个时钟周期被断言。</td><td>Low-Power Signaling feature 和 Response Ack feature</td></tr><tr><td>AckCreditRdy</td><td>1</td><td>Originator 或 pervasive logic</td><td>Acknowledge credit ready。</br>此信号用于为了时钟同步目的调节跨接口的响应确认 credit 信息流。有关 *Rdy / *Vld 握手的更多信息，请参见 Signaling Requirements。</td><td></td></tr></tbody></table><h5 id=a-id2210-probe-request-channel2210-probe-request-channela><a id="2.2.10 Probe Request Channel">2.2.10 Probe Request Channel</a></h5><p>探测请求通道由 Fabric 用于向一致性 Originator 发送探测请求和其他系统消息，包括每个一致性 Originator 后面的多个探测单元（probe unit）。
一个一致性探测单元表现为两个独立的一致性 Originator，其中 ReqUnitID 中的一个配置位指定探测单元。
这些探测单元共享一个探测请求、探测响应和 Originator 数据通道，但具有独立的 PrbVld 和 PrbRspVld 信号。
由于逻辑上只有一个探测单元可以对单个探测请求返回数据，因此只有一个 OrigDataVld 信号。</p><p>Fabric 生成探测请求，作为满足 Originator 发起的一致性读或写请求的一部分。
探测请求通道还用于向能够处理这些消息的处理器发送系统消息，例如分布式虚拟内存（DVM）和系统事件（中断）。
对于包含参与系统缓存一致性协议的缓存或处理系统消息的 Originator，此通道是必需的。
Completer 端口不包含此通道。</p><p><a id="表 29 Probe Request Channel Signals">表 29 Probe Request Channel Signals</a> 列出了构成探测请求通道的信号。</p><p>探测请求通道可以选择性地支持额外的 <strong>Probe Compression Feature（探测压缩特性）</strong>。有关更多信息，请参见 <em><a href="#Probe Compression Feature">Probe Compression Feature</a></em> 。</p><p><a id="表 29 Probe Request Channel Signals">表 29 Probe Request Channel Signals</a></p><table><thead><tr><th>名称</th><th>大小</th><th>Originator 端口驱动方</th><th>描述</th><th>必需</th></tr></thead><tbody><tr><td>PrbTag</td><td>N <sub>pt</sub></td><td>Port</td><td>探测请求标签。</br>用于在探测请求未完成时唯一标识探测请求，并将探测响应（如果有）与探测匹配。<br><br>当需要响应时（如所有一致性探测和某些系统管理消息的情况），PrbTag 用于将探测响应与探测匹配。Completer 在收到探测响应之前不得重用 PrbTag。由于 Originator 数据通道依赖于数据的顺序且不包含标签，因此即使在任何相关数据到达之前，PrbTag 也可以被重用。每个探测响应都包含其满足的探测请求的标签。<br><br>当不需要响应时，PrbTag 字段保留。PrbAction 的编码决定是否不需要响应。<br><br><strong>注意</strong>：PrbTag 与原始请求使用的 ReqTag 无关，架构中没有方法将两者关联起来。</td><td>Probe Support Feature（探测支持特性）</td></tr><tr><td>PrbAddr</td><td>N <sub>pa</sub></td><td>Port</td><td>探测请求地址。</br>此字段指示被探测的缓存行的地址，或者对于 DVM / 系统消息，是消息特定的信息。有关此字段的更多信息，请参见下文的 <em><a href=#PrbAddr>PrbAddr</a></em> 。</td><td>Probe Support Feature（探测支持特性）</td></tr><tr><td>PrbAction</td><td>4</td><td>Port</td><td>探测操作。</br>对于探测请求，此字段用于根据其当前状态指定被探测缓存行要进入的预期下一个状态。</br>也用于指示此请求是 DVM / 系统消息而不是探测请求。有关此字段的编码，请参见下文的 <em><a href=#PrbAction。>PrbAction。</a></em> 。</td><td>Probe Support Feature（探测支持特性）</td></tr><tr><td>PrbRD</td><td>2</td><td>Port</td><td>探测请求返回数据。</br>指示在何种情况下被探测的缓存应返回数据。</br>如果 PrbAction 是 DVM / 系统消息（10xxb），此字段保留。</br>有关此字段的编码，请参见下文的 <em><a href=#PrbRD>PrbRD</a></em> 。</td><td>Probe Support Feature（探测支持特性）</td></tr><tr><td>PrbChain</td><td>1</td><td>Port</td><td>当此字段设置为 1 时，指示此系统消息与具有相同 PrbAction 的后续探测请求配对。这仅用于 DVMOpMsg。如果 PrbAction 不是“DVMOpMsg，不需要响应”（编码 1000b），此字段保留。有关更多信息，请参见 href ** 和 DVM Operations**。</td><td>Probe Chain Feature（探测链特性）</td></tr><tr><td>PrbVld</td><td>N <sub>pu</sub></td><td>Port</td><td>探测请求有效。</br>这些信号指示端口呈现的探测地址和控制信息对于每个探测单元都是有效的。</br>在给定周期内，可以断言多个 PrbVld 信号，在这种情况下，探测将发送到所有被断言的单元（如 PrbRdy 指示）。</td><td>Probe Support Feature（探测支持特性）</td></tr><tr><td>PrbClkEn_m1</td><td>1</td><td>Port</td><td>探测时钟使能。</br>PrbClkEn_m1 必须在任何 PrbVld 信号断言的前一个时钟周期被断言。</td><td>Low-Power Signaling Feature 和探测支持特性</td></tr><tr><td>PrbRdy</td><td>1</td><td>Originator 或普适逻辑</td><td>探测请求就绪。</br>此信号用于为时钟同步目的调节跨接口的探测请求信息流。有关 *Rdy / *Vld 握手的更多信息，请参见 <em><a href="#2.4 信号需求">2.4 信号需求</a></em> 。</td><td>Probe Support Feature（探测支持特性）</td></tr><tr><td>PrbParity</td><td>1</td><td>Port</td><td>探测奇偶校验。</br>维护除 PrbVld、PrbClkEn_m1 和 PrbCreditRdy 之外的所有由端口驱动的探测请求通道字段的偶校验。</td><td>Enhanced RAS V1 Feature</td></tr><tr><td>PrbCreditCnt</td><td>N <sub>cc</sub><sup>[4]</sup></td><td>Port</td><td>返回的信用数的零起点字段。</td><td>Credit Count Feature</td></tr><tr><td>PrbCreditVld</td><td>1</td><td>Originator</td><td>探测信用有效。</br>Originator 在信用释放子通道上提供的信息是有效的。</td><td>Probe Support Feature（探测支持特性）</td></tr><tr><td>PrbCreditClkEn_m1</td><td>1</td><td>Originator</td><td>探测时钟使能。</br>PrbCreditClkEn_m1 必须在 PrbCreditVld 断言的前一个时钟周期被断言。</td><td>Low-Power Signaling Feature 和探测支持特性</td></tr><tr><td>PrbCreditRdy</td><td>1</td><td>Port 或普适逻辑</td><td>探测信用就绪。此信号用于为时钟同步目的调节跨接口的探测请求信用信息流。有关 *Rdy / *Vld 握手的更多信息，请参见“Signaling Requirements”。</td><td>Probe Support Feature（探测支持特性）</td></tr><tr><td>PrbCompType</td><td>2</td><td>Port</td><td>指定探测的类型——普通、带索引加载的普通或压缩。有关更多信息，请参见 <em><a href="#Probe Compression Feature">Probe Compression Feature</a></em> 。</td><td>Probe Compression Feature（探测压缩特性）</td></tr><tr><td>PrbCompIndex</td><td>N <sub>ct</sub></td><td>Port</td><td>指定探测压缩索引表。有关更多信息，请参见 <em><a href="#Probe Compression Feature">Probe Compression Feature</a></em> 。</td><td>Probe Compression Feature（探测压缩特性）</td></tr></tbody></table><p><a id=PrbAddr>PrbAddr</a></p><p>在不支持 DVM / 系统消息的系统中，PrbAddr 的宽度由系统支持的物理地址大小决定。
所有支持 DVM 的 Originator 都需要实现 <em><a href="#表 83 DVM Field Assignments">表 83 DVM Field Assignments</a></em> 中指定的 PrbAddr 位。
为支持 DVM 所需的任何附加位在内存一致性探测中设置为零。
所有支持存储探测（引导事务）的 Originator 都需要实现 <em>&lt;a href="#表 51 存储探测 PrbAddr 用法"</em>>表 51 存储探测 PrbAddr 用法*/a>* 中指定的 PrbAddr 位。
所有支持系统消息的 Originator 都需要实现 <em><a href="#3.10 系统消息">3.10 系统消息</a></em> 中指定的 PrbAddr 位。
不支持 DVM、系统消息和存储探测的 Originator 不需要实现 PrbAddr[5:2]。
PrbAddr[1:0] 保留，未实现。对于某些 DVM 和系统消息，PrbAddr 字段可能采用 <em><a href="#3.10 系统消息">3.10 系统消息</a></em> 中描述的修改编码。</p><p><a id=PrbAction>PrbAction</a></p><p>指定探测请求的缓存行状态的预期更改、DVM / 系统管理消息，以及/或是否需要探测响应。
高两位（PrbAction[3:2]）指示它是一个一致性探测还是 DVM 操作或系统消息。
当 PrbAction 为 1001b 至 10011b 时，PrbAddr 被解码以确定系统管理消息。</p><p>请参见 <em><a href="#表 30 PrbAction 编码">表 30 PrbAction 编码</a></em> 。</p><p><a id="表 30 PrbAction 编码">表 30 PrbAction 编码</a></p><table><thead><tr><th>PrbAction[3:2]</th><th>类型</th><th>PrbAction[3:0]</th><th>请求的操作</th></tr></thead><tbody><tr><td>0b</td><td>一致性</td><td>0000b/0h</td><td>NOP/No Change（无操作/不更改）</td></tr><tr><td></td><td></td><td>0001b/1h</td><td>Share（共享）</td></tr><tr><td></td><td></td><td>0010b/2h</td><td>Fetch（获取）</td></tr><tr><td></td><td></td><td>0011b/3h</td><td>Clean（清除）</td></tr><tr><td></td><td></td><td>0100b/4h</td><td>Migrate（迁移）</td></tr><tr><td></td><td></td><td>0101b/5h</td><td>Rinse（冲洗）</td></tr><tr><td></td><td></td><td>0110b/6h</td><td>Invalidate（无效化）</td></tr><tr><td></td><td></td><td>0111b/7h</td><td>Store（存储）。有关存储探测的更多信息，请参见 <em><a href="#3.9.8 存储探测">3.9.8 存储探测</a></em> 。</td></tr><tr><td>10x</td><td>DVM 或系统管理</td><td>1000b/8h</td><td>DVMOpMsg，不需要响应</td></tr><tr><td></td><td></td><td>1001b/9h</td><td>系统管理消息 - 不需要响应。包括 DVMSyncMsg。</td></tr><tr><td></td><td></td><td>1010b/Ah</td><td>保留<br><strong>架构注意</strong>：此 PrbAction 编码在 Fabric 上用于内部中断消息。</td></tr><tr><td></td><td></td><td>1011b/Bh</td><td>系统管理消息 - 需要响应</td></tr><tr><td>11x</td><td>一致性</td><td>1100b/Ch</td><td>保留<br><strong>架构注意</strong>：此 PrbAction 编码由 Fabric 用作 PageInvalidate 以无效化整个页面。然而，Fabric 将其转换为多个缓存行 Invalidate（6h）命令。</td></tr><tr><td></td><td></td><td>1101b/Dh</td><td>Demote（降级）<br><strong>架构注意</strong>：此 PrbAction 编码也由 Fabric 用作 PageDemote 以降级整个页面。然而，Fabric 将其转换为多个缓存行 Demote（Dh）命令。Fabric 上没有缓存行降级编码。</td></tr><tr><td></td><td></td><td>1110b/Eh</td><td>保留<br><strong>架构注意</strong>：此 PrbAction 编码由 Fabric 使用。</td></tr><tr><td></td><td></td><td>1111b/Fh</td><td>保留</td></tr></tbody></table><p><a id=PrbRD>PrbRD</a></p><p><em><a href="#表 31 PrbRD 编码">表 31 PrbRD 编码</a></em></p><table><thead><tr><th>PrbRD</th><th>请求的数据返回</th></tr></thead><tbody><tr><td>00b</td><td>不返回数据。<br>此编码对于所有要求降级“脏数据”的 PrbAction 字段都是非法的。</td></tr><tr><td>01b</td><td>如果缓存行处于 M、D、Mp 或 O 状态，则返回数据。</td></tr><tr><td>10b</td><td>如果缓存行处于 M、D、Mp、O、E 或 F 状态，则返回数据（如果缓存行状态为 E 或 F，可能不返回数据）。</td></tr><tr><td>11b</td><td>如果缓存行处于 M、D、Mp、O、E、S 或 F 状态，则返回数据（如果缓存行状态为 E、F 或 S，可能不返回数据）。</td></tr></tbody></table><p><a id=PrbChain>PrbChain</a></p><p>此字段仅用于 DVMOpMsg 探测数据包（PrbAction 为 1000b），并指示必须一起处理的 DVM 数据包对中的第一个。
PrbChain 对于所有一致性和其他系统管理探测数据包都是保留的（必须为零）。</p><p>DVMOpMsg 将消息的元数据放置在 PrbAddr 字段中，但它包含的数据比单个 PrbAddr 字段所能容纳的更多，因此消息分布在两个探测数据包中。</p><p>当在探测链上收到 PrbChain=1 的数据包时，Originator 应保留 PrbAddr，直到在探测请求通道上收到具有相同 PrbAction 为 1000b 的第二个（后续）数据包。
第二个数据包的 PrbChain=0，除了 PrbAddr 之外的其他字段（如 PrbTag）相同。
对于 DVMOpMsg 探测数据包，PrbRD 保留，且在两个数据包中都必须为零。</p><p>收到第二个数据包（PrbAction=1000b 且 PrbChain=0）后，Originator 将两个 PrbAddr 字段组合为一个 DVMOpMsg，如 <em><a href="#DVM Operations">DVM Operations</a></em> 中所述。
在这两个数据包之间，可能会有其他一致性或系统管理探测数据包，但不能有：</p><ol><li>DVMSync 消息。</li><li>另一个 PrbChain=1 的 DVMOpMsg。此情况特别保留，以防将来的规范变体需要三或更多探测数据包来处理某些 DVM 操作消息。</li><li>SysMgmtJoin 消息。</li><li>或者 SysMgmtLeave 消息。</li></ol><p>DVMOp 消息中的两个探测数据包使用单独的信用，具有独立的分配。在探测请求通道上接受 DVMOpMsg 的客户端必须要么发送至少两个信用，要么释放第一个信用（在单独的缓冲区中保留 PrbAddr），以便第二个数据包可以被传递。</p><p>有关更多信息，请参见 <em><a href="#DVM Operations">DVM Operations</a></em> *。</p><p><a id="Probe Compression Feature">Probe Compression Feature</a></p><p>探测压缩特性要求双方（Originator 和端口 / Fabric）实现一个包含 2^Nct 个条目的“探测压缩表”。每个条目可以容纳 PrbAddr[n:16]，其中 n 由 Npa 指定（PrbAddr 中的最高物理地址位）。该表由探测压缩索引（当 PrbCompType=01b 时在 PrbCompIndex 中指定）进行索引。当 PrbCompType=10b 时，有两个压缩索引——一个（PrbCompIndex0）在 PrbCompIndex0 中指定，另一个（PrbCompIndex1）在 PrbAddr 中指定。如果未断言任何 PrbVld 信号，PrbCompType 被忽略，操作方式如同 PrbCompType=00b。所有系统管理消息必须指定 PrbCompType=00b。</p><p>PrbCompType 的编码如 <em><a href="#表32 PrbCompType 编码">表32 PrbCompType 编码</a></em> 所示。</p><p><strong><a id="表 32 PrbCompType 编码">表 32 PrbCompType 编码</a></strong></p><table><thead><tr><th>PrbCompType</th><th>返回的数据请求</th></tr></thead><tbody><tr><td>00b</td><td>传输的探测请求和 PrbAddr 不使用探测压缩特性，PrbAddr 被视为未压缩。未具有探测压缩特性的端口的操作方式如同 PrbCompType 始终为 00b。</td></tr><tr><td>01b</td><td>传输的探测请求和 PrbAddr 是一个未压缩的单一地址。然而，Originator 被指示使用 PrbAddr[n:16] 加载索引为 PrbCompIndex 的探测压缩表。该表条目中任何先前的内容都将被丢弃。加载探测压缩表后，Originator 根据探测通道中的剩余字段处理探测。</td></tr><tr><td>10b</td><td>传输的探测请求和 PrbAddr 包含两个独立的地址（同时消耗一个探测信用）。这两个探测被作为两个完全独立且唯一的探测处理，将分别称为“probe0”和“probe1”，除了 PrbVld 外的所有非信用字段都有两个变体，标记为“0”和“1”（例如，probe0 的 PrbAction0 和 probe1 的 PrbAction1）。通常，probe0 使用端口信号，probe1 使用 PrbAddr 的某些部分，如下所示。当存在多个可探测单元（以及多个 PrbVld 信号）时，这两个探测由 PrbVld 指定的可探测单元处理。<br><br>对于第一个探测：<br><br>字段</td></tr><tr><td>11b</td><td>保留</td></tr></tbody></table><p>端口（或 Fabric）控制表的加载，一旦通过 PrbCompType=01b 加载后，可以使用 PrbCompType=10b 在一个 SDP 事务中发送两个压缩探测。在压缩探测中，由于探测地址的高位从探测压缩表中指定，这释放了 PrbAddr 的部分空间，用于保存这两个探测中第二个探测所使用的 PrbAction、PrbTag、PrbRD 和 PrbCompIndex 的单独副本。</p><p>探测压缩特性不改变 SDP 信用处理。当 PrbCompType 指定两个压缩探测（10b）时，即使在一个事务中有两个探测，该事务仍然消耗一个探测信用。探测压缩特性也不改变探测响应通道。除了使用单个探测信用外，每个压缩探测都是独立的，必须以两个唯一的响应进行响应。对于这两个探测的响应顺序，没有任何特定的要求。</p><p>端口指定未先前加载的 PrbCompIndex 值的压缩探测是非法的。探测表重置为所有条目均无效的状态，直到加载后才能使用。此外，Originator 可能在电源管理事件期间清除探测压缩表。通知端口 Originator 已经历电源管理的方法超出了本规范的范围。</p><p>所有系统管理探测消息必须指定 PrbCompType=00b。探测压缩特性仅可用于内存一致性探测（当 PrbAction != 10xx 时）。</p><h5 id=a-id2211-probe-response-channel2211-probe-response-channela><a id="2.2.11 Probe Response Channel">2.2.11 Probe Response Channel</a></h5><p><code>OrigDataChan</code>字段指示数据是写数据还是探测响应数据。表34列出了构成发起者数据通道的信号。由于写数据和探测响应数据的传输必须独立，因此在描述其中一个数据流时，可能会提到“发起者写数据通道”或“发起者探测数据通道”。</p><p><strong><a id="表  Originator (Write/Probe) Data Channel Signals">表 Originator (Write/Probe) Data Channel Signals</a></strong></p><table><thead><tr><th>名称</th><th>大小</th><th>驱动方</th><th>描述</th><th>必需功能</th></tr></thead><tbody><tr><td><strong>OrigDataChan</strong></td><td>1</td><td>发起者</td><td>如果为1，通道携带探测响应数据；如果为0，通道携带写数据。如果不存在探测请求通道，则此位不存在，默认假设为0。</td><td>探测支持功能</td></tr><tr><td><strong>OrigData</strong></td><td>Nod</td><td>发起者</td><td>发起者数据。写请求或探测响应数据。此字段的大小取决于实现，但必须是8位（一个字节）的整数倍，最大可达系统缓存行大小。</td><td>是</td></tr><tr><td><strong>OrigDataBytEn</strong></td><td>如果支持元数据压缩，则为Max(Nbe,Nmd)；如果支持字节使能压缩，则为1；否则为Nbe</td><td>发起者</td><td>发起者数据字节使能。<br><br>如果不支持字节使能压缩，则对于<code>OrigData</code>字段的每8位（一个字节）都有一个<code>OrigDataBytEn</code>位。这些信号指示哪些字节通道包含有效数据。对写请求数据和探测响应数据都有效。<br><br>如果支持字节使能压缩，则只有一个<code>OrigDataBytEn</code>位，如果有字节使能正在传输，则在数据传输的第一个节拍（beat）上断言。如果数据节拍上没有传输字节使能，则字节使能全部断言。详见“字节使能压缩”。<br><br>如果支持元数据压缩，任何与<code>ReqAttr[7:6] != 00b</code>的<code>WrSized*</code>关联的发起者数据都在低位携带元数据（<code>OrigDataBytEn[Nmd-2:0]</code>），并在<code>OrigDataBytEn[Nmd-1]</code>中携带偶校验。高于<code>Nmd</code>的任何位将被忽略。对于元数据压缩写入，实际的字节使能被视为全1。详见“元数据压缩”。</td><td>是</td></tr><tr><td><strong>OrigDataLast</strong></td><td>1</td><td>发起者</td><td>发起者数据结束。此信号指示发起者数据传输中的最后一个节拍。</td><td>是</td></tr><tr><td><strong>OrigDataError</strong></td><td>1</td><td>发起者</td><td>发起者数据错误。当断言此信号时，表示当前数据节拍包含数据错误。对写请求和探测响应数据都有效。</td><td>是</td></tr><tr><td><strong>OrigDataOffset</strong></td><td>Nodoff</td><td>发起者</td><td>发起者数据偏移。指示当前数据节拍的索引。详见下文的“OrigDataOffset”。</td><td>是</td></tr><tr><td><strong>OrigDataVC</strong></td><td>Nrvc</td><td>发起者</td><td>发起者数据虚拟通道。用于数据传输的虚拟通道。对于写数据，此字段必须与写入的<code>ReqVC</code>匹配。对于探测数据，此字段保留。</td><td>虚拟通道支持</td></tr><tr><td><strong>OrigDataParity</strong></td><td>Nod/64</td><td>发起者</td><td>发起者数据奇偶校验。<code>OrigDataParity</code>中的每一位为<code>OrigData</code>字段提供基于偶校验的错误保护。<code>OrigDataParity[i]</code>和<code>OrigData[((i+1)*64-1):(i*64)]</code>中设置的位数始终为偶数，包括<code>OrigDataBytEn</code>屏蔽部分或全部字节的奇偶校验组中的数据字节。<br><br>每64位提供一位奇偶校验。如果<code>OrigData</code>字段宽度除以64不是整数，应为剩余的（<code>Nrd MOD 64</code>）位提供一个单独的偶校验位。</td><td>是，除非<code>OrigDataUser</code>位实现了更高级的保护，例如ECC</td></tr><tr><td><strong>OrigDataMetaParity</strong></td><td>1</td><td>发起者</td><td>发起者数据元数据奇偶校验。维护所有发起者驱动（或在Completer端口由端口驱动）的信号的偶校验，除了<code>OrigData</code>、<code>OrigDataParity</code>、<code>OrigDataVld</code>、<code>OrigDataClkEn_m1</code>和<code>OrigDataCreditRdy</code>。</td><td>增强型RAS V1功能</td></tr><tr><td><strong>OrigDataChanAB</strong></td><td>1<sup>1</sup></td><td>发起者</td><td>发起者数据通道A/B选择。仅在Completer端口定义。<br>• 0：呈现的数据是通道A上的写请求。<br>• 1：呈现的数据是通道B上的写请求。</td><td>物理通道复用功能</td></tr><tr><td><strong>OrigDataVld</strong></td><td>1</td><td>发起者</td><td>发起者数据有效。此信号指示在发起者数据通道上呈现的信息是有效的。<br><br>当实现了多个探测单元时，这些探测单元共享一个发起者数据通道和一个<code>OrigDataVld</code>信号。由于一致性状态，在任何单个探测上，逻辑上不可能有多个探测单元响应数据，因此不需要有<code>Npu</code>个<code>OrigDataVld</code>信号。</td><td>是</td></tr><tr><td><strong>OrigDataClkEn_m1</strong></td><td>1</td><td>发起者</td><td>发起者数据时钟使能。<code>OrigDataClkEn_m1</code>必须在<code>OrigDataVld</code>断言的前一个时钟周期被断言。</td><td>低功耗信令功能</td></tr><tr><td><strong>OrigDataRdy</strong></td><td>1</td><td>端口或通用逻辑</td><td>发起者数据就绪。此信号用于为时钟同步目的调节跨接口的发起者数据流。有关*Rdy / *Vld握手的更多信息，请参见“信令要求”。</td><td>是</td></tr><tr><td><strong>OrigDataCreditChanAB</strong></td><td>1<sup>2</sup></td><td>发起者</td><td>发起者数据信用释放通道A/B。由Completer用于指示哪个通道正在释放信用。仅在Completer端口定义。<br>• 0：信用属于通道A。<br>• 1：信用属于通道B。</td><td>物理通道复用功能</td></tr><tr><td><strong>OrigDataPrbCreditRel</strong></td><td>1</td><td>端口</td><td>发起者数据探测信用释放。<br>• 0：正在释放的信用用于写数据，或者当未实现虚拟通道支持时，释放的信用也可以是可用于其他写数据或探测响应数据的池信用。<br>• 1：正在释放的信用用于探测响应数据。<br><br>如果未实现，此字段被视为0。在Completer端口或不支持探测的发起者端口上未实现。有关更多信息，请参见“信用释放子通道”。</td><td>探测支持功能</td></tr><tr><td><strong>OrigDataCreditType</strong></td><td>1</td><td>端口</td><td>发起者数据信用类型。当设置时，正在释放的信用是一个池信用，可用于任何虚拟通道集中的写数据或探测响应数据。当清除时，信用要么用于<code>OrigDataCreditVC</code>虚拟通道中的写数据（当<code>OrigDataPrbCreditRel</code>为0时），要么用于探测响应数据（当<code>OrigDataPrbCreditRel</code>为1时）。有关更多信息，请参见“信用释放子通道”。</td><td>虚拟通道支持</td></tr><tr><td><strong>OrigDataCreditVC</strong></td><td>Nrvc</td><td>端口</td><td>发起者数据信用虚拟通道。正在释放的信用的虚拟通道。仅当<code>OrigDataCreditType = 0</code>且<code>OrigDataPrbCreditRel = 0</code>时有效。有关更多信息，请参见“信用释放子通道”。</td><td>虚拟通道支持</td></tr><tr><td><strong>OrigDataCreditParity</strong></td><td>1</td><td>端口</td><td>发起者数据信用奇偶校验。维护已实现的<code>OrigData*Credit*</code>字段的偶校验，除了<code>OrigDataCreditVld</code>、<code>OrigDataCreditClkEn_m1</code>和<code>OrigDataCreditRdy</code>。</td><td>增强型RAS V3功能</td></tr><tr><td><strong>OrigDataCreditCnt</strong></td><td>Ncc[6]</td><td>端口</td><td>返回的信用数量的零起点字段。</td><td>信用计数功能</td></tr><tr><td><strong>OrigDataCreditVld</strong></td><td>1</td><td>端口</td><td>发起者数据信用有效。由端口（或Completer）在信用释放子通道上提供的信息是有效的。</td><td>是</td></tr><tr><td><strong>OrigDataCreditClkEn_m1</strong></td><td>1</td><td>端口</td><td>发起者数据信用时钟使能。<code>OrigDataCreditClkEn_m1</code>必须在<code>OrigDataCreditVld</code>断言的前一个时钟周期被断言。</td><td>低功耗信令功能</td></tr><tr><td><strong>OrigDataCreditRdy</strong></td><td>1</td><td>发起者或通用逻辑</td><td>发起者数据信用就绪。此信号用于为时钟同步目的调节跨接口的发起者数据信用信息流。有关*Rdy / *Vld握手的更多信息，请参见“信令要求”。</td><td>是</td></tr><tr><td><strong>OrigDataUser</strong></td><td>—</td><td>发起者</td><td>用户定义。</td><td>用户定义</td></tr></tbody></table><p><strong>注释：</strong></p><ol><li><p>在Completer端口由端口驱动；在发起者端口不支持。</p></li><li><p>在Completer端口由Completer驱动；在发起者端口不支持。</p></li></ol><p><a id=OrigDataOffset>OrigDataOffset</a></p><p>要写入的数据在一个或多个称为节拍（beats）的周期中从发起者传输到<code>OrigData</code>字段中。每个节拍根据内存中数据的顺序，从0开始顺序编号，直到<code>n-1</code>；<code>n</code>是传输要写入的数据所需的节拍总数。当传输需要多个节拍时，允许发起者以不同于顺序的顺序传输节拍。此字段提供当前传输周期中正在呈现的节拍编号。</p><p>节拍0（<code>OrigDataOffset = 0</code>）将始终包含数据有效载荷的初始（最低地址）字节。</p><p>对于双操作数矢量原子操作，第二个操作数数据的<code>OrigDataOffset</code>相对于内存地址加上操作数的大小。</p><hr><p><a id=信用释放子通道>信用释放子通道</a></p><p>每当在有效边沿断言<code>OrigDataCreditVld</code>信号时，都会释放一个或多个数据信用。<code>OrigDataCreditCnt</code>、<code>OrigDataPrbCreditRel</code>、<code>OrigDataCreditType</code>和<code>OrigDataCreditVC</code>字段指定信用的类型和数量，如下表所示。当未实现任何可选的<code>OrigData*Credit*</code>字段时，每当在有效时钟边沿断言<code>OrigDataCreditVld</code>信号时，都会释放一个写数据信用。</p><p>要求返回探测响应数据的发起者必须为探测响应数据保留至少一个池信用，以防止死锁。</p><p><a id="表 34  Originator (Write/Probe) Data Credit Type">表 34 Originator (Write/Probe) Data Credit Type</a></p><table><thead><tr><th><strong>CreditType</strong></th><th><strong>PrbCreditRel</strong></th><th><strong>CreditVC</strong></th><th><strong>虚拟通道支持</strong></th><th><strong>信用类型</strong></th></tr></thead><tbody><tr><td>1</td><td>无关</td><td>无关</td><td>无关</td><td>正在释放的信用可用于发起者的写数据（在任何虚拟通道中）或探测响应数据。</td></tr><tr><td>0</td><td>1</td><td>无关</td><td>无关</td><td>正在释放的信用可用于发起者的探测响应数据；或从先前的探测响应数据传输中返回。</td></tr><tr><td>0</td><td>0</td><td>任何值</td><td>是</td><td>正在释放的信用可用于发起者在<code>OrigDataCreditVC</code>指定的虚拟通道中的写数据；或从先前在<code>OrigDataCreditVC</code>指定的虚拟通道中的写数据传输中返回。</td></tr><tr><td>不适用</td><td>否</td><td>—</td><td>—</td><td>正在释放的信用是：<br>• 池信用，可用于发起者的写数据或探测响应数据。<br>• 信用，可用于发起者在<code>OrigDataCreditVC</code>指定的虚拟通道中的写数据；或从先前在<code>OrigDataCreditVC</code>指定的虚拟通道中的写数据传输中返回。</td></tr></tbody></table><h4 id=a-id23-端口参数化23-端口参数化a><a id="2.3 端口参数化">2.3 端口参数化</a></h4><p><strong>Scalable Data Port</strong> 架构允许对各种 <strong>Field</strong> 宽度进行参数化，以支持不同的应用和实现。许多参数是独立的，但并非全部。必须匹配的 <strong>Field</strong> 宽度共享相同的参数名称。例如，<strong>ReqTag</strong> 的位数必须与 <strong>RdRspTag</strong> 的位数相同。该值由名为 <strong>Nrt</strong> 的变量表示。</p><p>表 36 <strong>Port Field Widths</strong> 列出了所有端口参数以及这些参数适用的 <strong>Fields</strong>。</p><hr><p><strong>表 36 Port Field Widths</strong></p><table><thead><tr><th><strong>Parameter</strong></th><th><strong>Port Field</strong></th></tr></thead><tbody><tr><td><strong>Nrt</strong></td><td>ReqTag, WrRspTag, RdRspTag, AckTag</td></tr><tr><td><strong>Nui</strong></td><td>ReqUnitID, WrRspUnitID, RdRspUnitID, AckUnitID</td></tr><tr><td><strong>Nrdoff</strong></td><td>RdRspOffset</td></tr><tr><td><strong>Nodoff</strong></td><td>OrigDataOffset</td></tr><tr><td><strong>Nrvc</strong></td><td>ReqVC, ReqCreditVC, RdRspVC, RdRespCreditVC, WrRspVC, OrigDataVC, OrigDataCreditVC</td></tr><tr><td><strong>Nra</strong></td><td>ReqAddr</td></tr><tr><td><strong>Nrsa</strong></td><td>ReqSubAddr</td></tr><tr><td><strong>Npa</strong></td><td>PrbAddr</td></tr><tr><td><strong>Nsi</strong></td><td>ReqStreamID</td></tr><tr><td><strong>Nvf</strong></td><td>ReqVfid</td></tr><tr><td><strong>Nod</strong></td><td>OrigData</td></tr><tr><td><strong>Nmd</strong></td><td>RdRspDataCompMeta</td></tr><tr><td><strong>Nbe</strong>，1，或 max(Nbe, Nmd)</td><td>OrigDataBytEn。此 <strong>Field</strong> 的宽度取决于 Byte Enable Compression 和 Metadata Compression 功能的支持。</td></tr><tr><td><strong>Nrd</strong></td><td>RdRspData</td></tr><tr><td><strong>Nrdstat</strong></td><td>RdRspStatus</td></tr><tr><td><strong>Npt</strong></td><td>PrbTag, PrbRspTag</td></tr><tr><td><strong>Nrl</strong></td><td>ReqLen</td></tr><tr><td><strong>Nshort_lag</strong></td><td>当 RdRspDelay = 0 时（或如果未实现 Variable Heads-up Feature，则始终如此），Response Sub-channel 与 Data-channel 之间的周期数（整数）。只要在端口激活之前双方具有相同的值，此值可以是可编程的。</td></tr><tr><td><strong>Nlong_lag</strong></td><td>当 RdRspDelay = 1 时，Response Sub-channel 与 Data-channel 之间的周期数（整数）。只要在端口激活之前双方具有相同的值，此值可以是可编程的。此参数仅用于实现 Variable Heads-up Feature 的端口。</td></tr><tr><td><strong>Nrdy_shift</strong></td><td>必须对 *Rdy 进行触发以使其与其指示的实际周期对齐的时钟周期数（整数）。例如，如果 Nrdy_shift 为 4，则提供 *Rdy_m4 以提前四个周期指示端口是否准备就绪。</td></tr><tr><td><strong>Npu</strong></td><td>在一致性 Originator 后面的 Probe Units 数量。每个 Probe Unit 都可以单独被探测。</td></tr><tr><td><strong>Nrsl</strong></td><td>ReqSecLevel</td></tr><tr><td><strong>Npri</strong></td><td>ReqQosPriority</td></tr><tr><td><strong>Nct</strong></td><td>PrbCompIndex。此功能指示可在 Probe Compression 功能中使用的索引表的数量的 log2。</td></tr><tr><td><strong>Ncc[6:0]</strong></td><td>ReqCreditCnt, AckCreditCnt, RdRspCreditCnt, WrRspCreditCnt, PrbCreditCnt, PrbRspCreditCnt，以及 OrigDataCreditCnt。作为信用计数为 “-1” 的值表示没有 *CreditCnt <strong>Field</strong>，因此每个信用隐式为一个信用（就像 *CreditCnt 为零一样）。</td></tr><tr><td><strong>Nst</strong></td><td>ReqStWayId</td></tr></tbody></table><p><strong>注意：</strong> 表中未包含表示用户定义 <strong>Field</strong> 宽度的参数。用户定义 <strong>Field</strong> 的宽度根据应用程序确定。</p><h4 id=a-id24-信号需求24-信号需求a><a id="2.4 信号需求">2.4 信号需求</a></h4><p><em><a href="#图 4">图 4</a></em> <strong>Port Interface Valid and Ready Signaling</strong> 概述了 SDP 接口的信令要求。</p><p><a id="图 4">图 4</br><img src=https://icjj.github.io/icer/img/post/sdp/4.png alt></a></p><p>每当 Originator 或 Completer 设备或其连接的 Port 的 *ClkAck 信号被断言时，它必须准备好接收所有已断言 *Rdy 的入站通道上的信息。信息在接口的源端呈现，并传输到接收端的锁存器中。</p><p>源端通过断言其 *Vld 信号来指示命令和数据信号在接口上是稳定的，接收端通过断言其 *Rdy 信号来指示它已准备好接收命令和数据信息。如果 Port 实现了 Low-Power Signaling 功能，源端还必须在任何断言 *Vld 的周期之前至少一个周期断言相应的 *ClkEn_m1 信号。传输发生在 *Vld 和 *Rdy 都为高电平的时钟上升沿。*Rdy 可以由实际的 Originator 或 Completer 驱动，或者可以由实际的 Originator 或 Completer 模块之外的普适逻辑断言以执行时钟同步，在这种情况下，可以忽略来自 Port 的任何 *Rdy 信号，并且 Port 必须在连接时始终准备就绪。一旦源端断言了 *Vld 信号，除非 Port 复位（SdpReset_N 的去断言），否则不应在观察到 *Rdy 之前取消断言它。</p><p>当源端未断言其 *Vld 信号时，该 Port 上的所有命令和数据信息都是无效的，必须被忽略。例如，不要求 ReqCmd 具有有效的编码，或者奇偶校验信号与数据一致。除了 Port Control 信号（*ClkReq、*ClkAck、*ClkCtl）和 SdpReset_N 的去断言外，SDP 接口上的所有信号都与系统普适逻辑提供的公共时钟（SdpClk）同步。预期源逻辑切换和信号传播时间应使得到下一个时钟上升沿有足够的时间裕量，以允许接收端接口上的简单组合逻辑。该逻辑可以执行诸如在数据/控制信息被锁存之前取消断言 *Rdy 或推进队列指针等功能。在一些高频实现中，*Rdy 信号也可以通过使用名为 Nrdy_shift 的 Port 参数，以整数个时钟周期提前提供。每个 *Rdy 信号将被替换或复制为信号 *Rdy_m&lt;Nrdy_shift>，以指示该信号被流水线了该数量的时钟。</p><p>请注意，接口接收端的逻辑块可以通过取消断言或延迟断言其 *Rdy 信号来阻止传输。这提供了一定程度的链路级节奏控制。然而，接收端逻辑不能使其 *Rdy 信号的断言取决于源端逻辑对 *Vld 信号的断言，或取决于其处理或缓存传入数据或命令信息的能力。这种节奏控制由更高级别的基于 Credit 的协议提供。
<em><a href="#图 5">图 5</a></em> <strong>Port Interface Reset Requirements</strong> 提供了关于接口初始化的信息。</p><p><a id="图 5">图 5</br><img src=https://icjj.github.io/icer/img/post/sdp/5.png alt></a></p><p>端口（或系统）复位信号 SdpReset_N 是一个负有效信号，用于初始化接口逻辑。预期在一次复位事件中不会保留任何状态信息。任何已建立的 Credit 都会被复位，任何未完成的事务都会被中止且不会收到响应。</p><p>虽然 SdpReset_N 的断言（负跳变沿）与 SdpClk 是异步的，但 SdpReset_N 的去断言（上升沿）必须与时钟同步。</p><p>当 SdpReset_N 处于活动状态时，*Vld 和 *Rdy 以及端口控制 *ClkReq 和 *ClkAck 信号必须处于非活动（低）状态。其他信号的状态为“不关心（don&rsquo;t care）”。接口上不会发生任何数据传输。</p><p>在复位之后，*ClkReq 信号必须保持非活动状态，直到 SdpReset_N 去断言后的第一个 SdpClk 上升沿之后。在此时，提供端口控制 *ClkReq 信号的逻辑块可以开始端口激活。*ClkAck 通常仅在观察到互补的 *ClkReq 信号断言后才会断言。</p><p>接收器逻辑块可以使用 *Rdy 信号指示其接收信息的准备状态。即使在 *ClkAck 之前，*Rdy 信号也可以断言，尽管在 *ClkAck 和 *Rdy 都被断言之前，通道无法接收信息。</p><p>**实现注意：**当端口涉及时钟跨越边界时，接收逻辑可能会在第一个时钟之前，甚至在它观察到复位去断言之前，观察到 *ClkReq 被断言，尽管源逻辑可能不会在其从复位中恢复后的第一个时钟之前断言。这可能发生，例如，当 *ClkReq 是一个异步信号时，端口两侧的频率差导致，或者由于超出本规范范围的时钟或复位结构的实际差异所致。接收器不应依赖于在复位后实际观察到输入的 *ClkReq 上的边沿。</p><h4 id=a-id25-端口控制25-端口控制a><a id="2.5 端口控制">2.5 端口控制</a></h4><p>SDP 提供了信号，允许端口以有序的序列进入活动状态或过渡到断开状态，从而消除可能破坏接口上信息传输的竞争条件。握手协议可以由接口两侧的状态机协调，或者直接由 SOC 级逻辑和/或管理固件协调。</p><p>在以下图表和讨论中，“originator”指的是在 Originator Port 的 originator 设备，或在 Completer Port 中作为 originator 代理的 Fabric 内的代理。“Completer”指的是在 Completer Port 的 completer 设备，或在 Originator Port 中作为 completer 代理的 Fabric 内的代理。</p><p>Port Control 使用四个信号：OrigClkReq、OrigClkAck、CompClkReq 和 CompClkAck。增强的 Port Control 增加了两个额外的信号：OrigClkCtl 和 CompClkCtl。</p><p>Originator 使用 OrigClkReq 来请求其出站通道的连接或断开。Completer 使用 CompClkAck 来确认 Originator 的请求。仅当 OrigClkReq 和 CompClkAck 都被断言时，Originator 到 Completer 的方向才处于活动状态，包括流控制 credits 在内的信息才能从 Originator 传递到 Completer（使用 *Vld 和 *Rdy 握手协议）。即使 Completer 到 Originator 的方向尚未（或尚未）激活，信息也可能从 Originator 流向 Completer。</p><p>Completer 使用 CompClkReq 来请求其出站通道的连接或断开。Originator 使用 OrigClkAck 来确认 Completer 的请求。仅当 CompClkReq 和 OrigClkAck 都被断言时，Completer 到 Originator 的方向才处于活动状态，包括流控制 credits 在内的信息才能从 Completer 传递到 Originator（使用 *Vld 和 *Rdy 握手协议）。即使 Originator 到 Completer 的方向尚未（或尚未）激活，信息也可能从 Completer 流向 Originator。</p><p>当两个方向都处于活动状态时（所有四个信号，*ClkReq 和 *ClkAck 都被断言），端口处于活动状态。</p><p>在下文中，本节将 Originator 或 Completer 称为 “agent”，并使用 *ClkReq 和 *ClkAck 来泛化端口的两侧。</p><p>促使 agent 启动激活、重新连接或断开连接的条件超出了本规范的范围。在某些情况下，这可能涉及外部固件操作，可能取决于有关端口连接或断开是否发生的配置信息。</p><h5 id=a-id251-activating-or-reconnecting-the-port251-activating-or-reconnecting-the-porta><a id="2.5.1 Activating or Reconnecting the Port">2.5.1 Activating or Reconnecting the Port</a></h5><p>为了使序列继续进行，端口需要被激活并且时钟保持同步。任意一个非发起的 agent 都可以通过延迟 *ClkAck 响应或推迟其 *ClkReq 的断言来阻止连接的完成。在断言 *ClkAck 之前，确认的 agent 必须准备好锁存由请求 agent 在其任何出站通道上提供的有效信息。一旦请求设备断言 *ClkReq，它必须在收到确认（即 *ClkAck 的断言）之前保持该信号的断言。</p><p>由于事务的流动要求首先通过相反方向的信息流动来建立信用，因此每一方都需要连接端口。Completer 可以等待 Originator 首先建立连接，或者两方可以独立地激活/重新连接。Originator 等待 Completer 首先建立连接是不合法的。</p><p><em><a href="#图 6">图 6</a></em> <strong>Originator-Initiated Activation</strong> 展示了在从完全断开（或重置）状态下发起的激活握手协议的断言序列。<br><em><a href="#图 7">图 7</a></em> <strong>Completer-Initiated Activation</strong> 展示了在从完全断开（或重置）状态下由 Completer 发起的激活握手协议的断言序列。</p><p><a id="图 6">图 6</br><img src=https://icjj.github.io/icer/img/post/sdp/6.png alt></a></p><p><a id="图 7">图 7</br><img src=https://icjj.github.io/icer/img/post/sdp/7.png alt></a></p><h5 id=a-id252-disconnecting-the-port--one-sided-disconnect252-disconnecting-the-port--one-sided-disconnecta><a id="2.5.2 Disconnecting the Port – One-sided Disconnect">2.5.2 Disconnecting the Port – One-sided Disconnect</a></h5><p><strong>单向断开</strong>表示发起 agent 已请求断开连接（通过取消断言 *ClkReq），并且非发起 agent 已确认请求（通过取消断言 *ClkAck），但尚未通过取消断言其 *ClkReq 来做出回应。</p><p>在单向断开状态下，发起 agent 无法断言 *Vld 或在任何其出站通道上提供信息（包括其入站通道的信用释放子通道）。此要求从 *ClkReq 取消断言时开始。发起 agent 必须保持准备状态，以接收其入站通道上的信息，包括其出站通道的信用释放子通道的信息。</p><p>发起 agent 无法关闭任何接收信息所需逻辑的电源或时钟，包括用于追踪从接收方在出站通道的信用释放子通道上接收到的信用数量的逻辑。</p><p>非发起 agent（继续保持其 *ClkReq 活跃）可以继续通过其出站通道发送信息，包括其入站通道的信用释放子通道，但可以关闭接收信息所需逻辑的时钟，包括接收其出站通道信用释放子通道的信息逻辑。</p><p>非发起 agent 可以通过延迟其 *ClkAck 取消断言响应来推迟对发起 agent 的断开请求的确认，但不能无限期地推迟。这个延迟可能是为了清空时钟同步 FIFO 或管道寄存器，但将此确认依赖于接收信用或完成未决事务或探测是非法的。这样的依赖关系将导致死锁，因为发起 agent 可能必须在重新断言 *ClkReq 后才能发送此信息，并且发起 agent 在观察到非发起 agent 取消断言 *ClkAck 之前无法重新断言 *ClkReq，这是非法的。</p><p>根据物理连接的实现，发起或确认 agent 可能有责任等待一个指定的时间，以便端口上最后发送的信息能够通过任何可能被断开连接影响的时钟同步逻辑。实现必须建立规则，如最小时钟数，以确保信息不会被滞留在两侧之间的任何同步逻辑中。这些规则超出了本文件的范围。</p><p><strong>实现注释</strong>：对于具有电压域跨越接口（VDCI）的 SOC-15 端口，在 VDCI 对所有通道上的 *_Empty<ch> 信号断言之前，延迟取消断言 *ClkReq 或 *ClkAck。</p><p>总线在单向断开之前可能已被静默，也可能未被静默，而端口的断开过程可以在响应、确认和/或信用返回尚未完成的情况下继续进行。在单向断开期间，端口的状态不会改变。所有未完成的事务和信用保持不变，仿佛端口仍处于连接状态。</p><p>完成单向断开的 agent 保留在断开请求被确认后任何时候通过重新断言 *ClkReq 发起重新连接的权利。发起 agent 必须在有信息要发送时重新连接，包括流控制信用。发起 agent 可以在重新连接之前设定一个时间限制（滞后），但不得对重新连接之前必须发送的信用数量设定阈值。</p><p>在某些情况下，端口的两侧可能独立或甚至同时经历单向断开。最终结果是，端口处于完全断开状态，唯一的例外是端口可能没有完全静默（可能仍有未完成的事务或信用）。</p><h5 id=a-id253-disconnecting-the-port--full-disconnect253-disconnecting-the-port--full-disconnecta><a id="2.5.3 Disconnecting the Port – Full Disconnect">2.5.3 Disconnecting the Port – Full Disconnect</a></h5><p>完全断开意味着接口的两侧都请求断开连接，通过取消断言各自的 *ClkReq 信号，并且双方都已确认这些请求。在完全断开的状态下，OrigClkReq、CompClkReq、OrigClkAck 和 CompClkAck 都是非活动的。所有 *Vld 信号都是非活动的，所有通道信息字段都被忽略。在此状态下，单方或双方的 agent 可以被电源或时钟门控。</p><p>为了实现电源管理，端口在完全断开之前，所有的请求、探测、响应、确认和流控流量必须静默。新的请求必须停止，所有的响应必须返回给请求者。流控制信用的发出或返回必须被静默或暂停。一旦所有信息流被停止，断开的握手可以由任一方发起。本规范假设断开是由发起方发起的，这在大多数情况下是更自然的，因为通常是发起方掌握哪些事务可能未完成，并且了解未来可能会有更多事务。</p><p>端口两侧处于完全断开状态时，具有与发起单向断开相同的要求，即在 *ClkReq 被取消断言后停止信息流、确认 *ClkReq、等待任何同步逻辑等。</p><p>非发起 agent 不一定需要通过取消断言 *ClkReq 来回应断开请求。SOC 级别的硬件和/或固件（不在本规范的范围内）可能使发起 agent 知道对方会回应。若非发起 agent 确实回应且发起 agent 确认断开，则端口被视为完全断开。</p><p>与单向断开一样，端口的状态预计会在完全断开期间保持。为了简化状态的维护，需要静默所有请求、探测、响应和流控流量。如果端口的其中一侧或两侧在断开期间被电源门控，agent 必须在重新连接之前重新初始化或恢复端口的状态。用于恢复电源门控后状态的方法不在本规范的范围内。实现增强端口控制功能的 agent 可以选择在完全断开后不重新初始化信用，并要求重新发送信用。如果未明确要求重新发送信用，或者未实现增强端口控制功能，agent 必须恢复断开之前对方给出的信用数量和类型。</p><p><strong><em><a href="#图 8">图 8</a></em> Originator-Initiated Full Disconnect</strong> 显示了在断开握手协议由发起方发起的情况下的断开序列。<strong><em><a href="#图 9">图 9</a></em> Completer-Initiated Full Disconnect</strong> 显示了在断开握手协议由接收方发起的情况下的断开序列。</p><p><a id="图 8">图 8</br><img src=https://icjj.github.io/icer/img/post/sdp/8.png alt></a></p><p><a id="图 9">图 9</br><img src=https://icjj.github.io/icer/img/post/sdp/9.png alt></a></p><h5 id=a-id254-enhanced-port-control-feature254-enhanced-port-control-featurea><a id="2.5.4 Enhanced Port Control Feature">2.5.4 Enhanced Port Control Feature</a></h5><p>增强端口控制功能添加了两个信号，OrigClkCtl 和 CompClkCtl，它们在端口连接和断开过程中都使用。</p><p>增强端口控制功能还提供了一种方式，通过该方式，断开的发起 agent 可以请求完全断开或单向断开。完全断开请求是一种提示，表示发起 agent 已准备进入电源门控状态，并将在一段时间内不请求重新连接。</p><p><strong>Connection with the Enhanced Port Control Feature</strong></p><p>增强端口控制功能提供了一种方式，使得发起方和/或接收方可以显式地请求对方在完全断开后重新连接时重新发出（或重新发放）流控信用。代理也可以显式请求在断开后不重新发放流控信用（如果代理没有丢失断开之前已释放的信用）。</p><p>为了与增强端口控制功能正常工作，从完全断开后重新连接的第一个 agent 可能需要等待另一侧建立连接后，才能发出信用。</p><p>如果不支持增强端口控制功能，则在连接过程中所需的任何流控信用初始化必须通过本规范范围之外的方式提供。</p><p><strong><em><a href="#图 10">图 10</a></em> 增强激活协议</strong> 显示了在激活由发起方发起的情况下的增强端口激活序列。</p><p><a id="图 10">图 10</br><img src=https://icjj.github.io/icer/img/post/sdp/10.png alt></a></p><p><strong>Disconnect</strong></p><p>发起方使用 <strong>OrigClkCtl</strong> 信号请求接收方为其出站通道发放（或重新发放）流控信用，或者请求接收方不为其出站通道发放（或重新发放）流控信用。发起方通过在断开请求（<strong>OrigClkReq</strong>）之前断言 <strong>OrigClkCtl</strong> 来请求发放流控信用；通过在断开请求之前去断言 <strong>OrigClkCtl</strong> 来表示不请求流控信用。</p><p>接收方使用 <strong>CompClkCtl</strong> 信号请求发起方为其出站通道发放（或重新发放）流控信用，或者请求发起方不为其出站通道发放（或重新发放）流控信用。接收方通过在断开请求（<strong>CompClkReq</strong>）之前断言 <strong>CompClkCtl</strong> 来请求发放流控信用；通过在断开请求之前去断言 <strong>CompClkCtl</strong> 来表示不请求流控信用。</p><p>需要注意的是，请求方必须保持 <strong>ClkCtl</strong> 信号的状态，直到它看到对连接请求的确认。如果请求方没有丢失它已经接收到的信用并且不希望对方重新发放信用，则在断言 <strong>ClkReq</strong> 时，<strong>ClkCtl</strong> 信号必须处于非激活状态。</p><p>代理在进行单向断开后不能请求重新发放流控信用，必须去断言 <strong>ClkCtl</strong>。</p><p>在第一次连接（即 <strong>SdpReset_N</strong> 去断言后），所有实现增强端口控制的代理都必须断言 <strong>ClkCtl</strong> 来表示信用释放，但也可以允许接收代理忽略该值，并假设端口重置后信用总是被释放。</p><p>在完全断开后的增强激活协议中，代理不能假设另一方会请求其重置并重新发放信用，仅因为第一个代理请求对方重置并重新发放信用。在上面的图中，发起方必须在断言 <strong>CompClkReq</strong> 之前采样 <strong>CompClkCtl</strong>，然后再向接收方发放信用。</p><p><a id="图 11">图 11</br><img src=https://icjj.github.io/icer/img/post/sdp/11.png alt></a></p><p>非发起 agent 必须确认断开请求，但可以推迟其自身的断开请求。通常，如果发起 agent 请求完全断开，非发起 agent 在准备完成断开时，也会请求完全断开，但这并不是必须的。可能会提供本规范范围之外的方法来取消完全断开请求，允许发起 agent 请求重新连接。</p><p><em><a href="#图 12">图 12</a></em> 显示了在完全断开请求从接口的 Completer 侧发起的情况下，增强断开协议的过程。</p><p><a id="图 12">图 12</br><img src=https://icjj.github.io/icer/img/post/sdp/12.png alt></a></p><h3 id=a-id第3章-事务层第3章-事务层a><a id="第3章 事务层">第3章 事务层</a></h3><h4 id=a-id31-事务层概述31-事务层概述a><a id="3.1 事务层概述">3.1 事务层概述</a></h4><p>一个 SDP 事务由多个阶段组成，这些阶段分布在多个物理通道上。一个一致性的发起者设备发出缓存感知的事务请求。当一致性的发起者请求读取和写入系统内存中的一个或多个字节时，它会根据其本地缓存中包含目标数据元素的块（缓存行）的预期用途（例如，写入、只读或读取并打算修改），在多种不同类型的请求（也称为命令）之间进行选择。缓存感知的命令可以对发起者的缓存目录和系统中的其他缓存产生隐式或显式的影响。</p><p><em><a href="#图 13">图 13</a></em> <strong>Scalable Data Port Interface</strong> 显示了按类型分组的 SDP 物理通道。</p><p><a id="图 13">图 13</br><img src=https://icjj.github.io/icer/img/post/sdp/13.png alt></a></p><p>在 SDP 的上下文中，发起者指的是在端口上生成请求的实体，而 Completer 是请求所指向的实体。发起者和 Completer 可以如图所示进行点对点连接。更常见的是，发起者和 Completer 通过通信网络（Fabric）间接连接。给定的 IP 模块可能使用多个端口，并且在某些端口上是发起者，而在其他端口上是 Completer。</p><p>事务流程由命令通道定义，这些通道按照它们在事务中使用的顺序列出。并非所有事务都使用所有通道。通常，事务由发起者在其发起者请求通道之一上启动。如果 Completer 是 Fabric，那么它可能会向各个发起者（包括请求的那个）生成探测请求，以收集满足请求所需的信息。（非 Fabric Completer 不生成探测。）每个被探测的发起者在其探测响应通道上进行响应。</p><p>Completer 生成适当的响应，并根据命令，通过读取响应通道或写入响应通道将其发送回发起者。最后，发起者可能生成响应确认，完成事务。</p><p>由于一个事务通常必须经过所有这些阶段才能完成，任何通道的阻塞都可能导致回溯并阻塞事务流程中较早的所有通道。因此，为了避免死锁，要求任何通道都不能使其发送数据的能力依赖于流程中更早的通道发送或接收。</p><p>在每个方向上都有一个数据通道，关联到同一方向上的一个或多个命令通道。发起者数据通道携带写请求和探测响应数据。发起者数据通道的仲裁必须保证即使另一种数据传输被阻塞，两种类型的数据传输都能够取得进展。读取响应通道携带读取响应的数据，以及 ChgToX、ChgToXNR 和 ValBlk。</p><p>最后，还有一些并非真正属于事务流程的附加通道。公共信号只是端口两侧共享的时钟和复位信号。</p><h4 id=a-id32-data-transfer32-data-transfera><a id="3.2 Data Transfer">3.2 Data Transfer</a></h4><p>SDP 有两个数据通道——Originator（Write/Probe）Data Channel（发起者到 Completer 方向）和 Read Response Channel（带有读取数据作为该通道的一部分，在 Completer 到 Originator 方向）。</p><p>数据传输请求在字节可寻址的系统内存地址空间中移动连续的、对齐的双字块。对于定长的读和写，这个块的初始地址（第一个双字的最低有效字节的地址）等于请求的 ReqAddr Field 的值。对于缓存读取和 ChgToX，块的初始地址等于请求的 ReqAddr Field 的值，且对齐到系统缓存行大小。对于双操作数原子操作，初始地址无关紧要，数据传输就像对缓存行的访问一样（如同 ReqAddr[5] 为零）。对于其他请求，初始地址等于请求的 ReqAddr Field 的值。由于地址是双字对齐的，地址的位 [1:0] 总是 0。</p><p>ReqLen 指定请求的双字数量减一。在以下讨论中，ReqSizeBytes 的值等于 4 × (ReqLen + 1)，即请求的字节数。注意，传输中字节的数量计数包括可能被屏蔽的连续双字块内的那些字节。单个请求的最大大小和地址对齐要求是实现特定的，对于读和写可能不同。</p><p>通过使用字节使能，可以在双字块内传输单个字节。如果字节使能为 0，则对应的字节被屏蔽（视为无效）。虽然数据字节上的实际值无关紧要，但它仍然会影响任何数据奇偶校验。此外，建议任何被屏蔽的字节被“围栏”，并以全零或全一提供，以避免未初始化数据的潜在安全泄漏。对于读请求，一个请求中传输的字节必须是连续的，且字节使能仅为第一个和最后一个双字提供。对于写请求，写入数据通过 Originator Data Channel 传输，为 OrigData Field 中的每个字节提供一个字节使能（OrigDataBytEn[i]）。OrigDataBytEn[0] 对应于字节 0，OrigDataBytEn[1] 对应于字节 1，依此类推。写入的字节使能可以是稀疏的——也就是说，不要求字节使能必须连续设置，也不要求在单个事务中设置任何字节使能。发起者必须将 ReqAddr/ReqLen 边界之外的字节通道的所有字节使能驱动为零，双操作数原子操作除外。对于双操作数原子操作，正在传输的缓存行中所有字节通道的字节使能为一。</p><p><strong>SOC-15 Scalable Data Port (SDP) Specification, 1.5.0, 11/10/2022 AMD Confidential – Internal Use Only</strong></p><p>在每个 *Vld 被断言的周期中，N 个字节通过接口传输，其中 N 小于或等于 *Data Field 的字节宽度（DataFieldWidth）。数据的每个字节都放置在 *Data Field 内其自然对齐的字节通道中。大于数据总线宽度的传输在多个周期（节拍）上发生，每个周期传输一个节拍的数据。每个节拍在传输期间仅传输一次。如果 ReqAddr 未对齐到 *Data Field 宽度，数据将左移，使得每个双字根据其地址定位在 *Data Field 中。在此移位中空出的通道在传输过程中被忽略。</p><p>不支持在 *Data Field 内的数据字节环绕。因此，当初始地址未对齐到 *Data Field 宽度且 ReqSizeBytes = DataFieldWidth 时，数据传输需要 2 个节拍。</p><p>与特定读或写请求相关的双字块内的节拍可以以任何顺序通过端口接口传输，除非在下面的实现注释中注明。传输的数据源选择节拍的顺序，并使用 *Offset Field 标识在给定周期中正在传输的节拍。包含初始双字的节拍的 *Offset 值为零。每个节拍的地址是请求的 ReqAddr 对齐到 *Data Field，加上 *Offset Field 的值乘以字段的字节宽度。</p><p>对于大于缓存行大小的传输，必须在移动到下一个缓存行大小的块之前传输每个对齐的缓存行大小块内的所有数据，但缓存行大小的块可以按照下面的实现注释中注明的任何顺序传输。最后一个节拍（即使只有一个）由 *Last 的断言指示。建议 Completers 在读响应中首先发送由原始请求地址指定的节拍，但不是必须的。实现可以保证和/或要求特定的数据节拍顺序以简化发起者的实现。</p><p>**实现注释：**SOC-15 Fabric 限制了响应数据顺序和写数据顺序，使得单个命令（唯一的 ReqTag）的数据总是以“地址顺序”传输，缓存读取和 ChgToX 命令除外。地址顺序意味着对于每个事务，<em>Offset Field 从零开始，每个后续的节拍将此 <em>Offset 增加一，使得数据总是从最低地址到最高地址观察。数据必须以地址顺序提供的限制适用于连接到数据 Fabric 的数据 Fabric 和所有发起者和 Completers。作为此规则的例外，SOC-15 Fabric 可以以任何顺序返回缓存读取（RdBlk</em>）和 ChgToX 命令的响应数据，而不管 ReqAddr[5:2]，并且当在单个 RdBlk</em> 命令中请求多个缓存行时，可以以任何顺序返回每个单独的缓存行。</p><p><em><a href="#图 14">图 14</a></em> <strong>Aligned Data Transfer</strong> 说明了当请求地址对齐到 *Data Field 的宽度时，数据字节在 *Data Field 内的对齐方式。</p><p><a id="图 14">图 14</br><img src=https://icjj.github.io/icer/img/post/sdp/14.png alt></a></p><p>在此示例中，*Data field 的宽度是 4 个 doubleword（128 位），并且一个对齐的 4 个 doubleword 块正在通过接口传输。Doubleword 0（DW 0）在字节通道 0–3（*Data[31:0]）中传输，Doubleword 1（DW 1）在字节通道 4–7（*Data[63:32]）中传输，Doubleword 2（DW 2）在字节通道 8–11（*Data[95:64]）中传输，Doubleword 3（DW 3）在字节通道 12–15（*Data[127:96]）中传输。Doubleword 内的每个字节都在自然对齐的位置传输。</p><p>如果 doubleword 块的起始地址未对齐到 <em>Data field，doubleword 将被移位，使得每个 doubleword 在 <em>Data field 内以其自然对齐的 doubleword 位置传输。</em><a href="#图 15">图 15</a></em> <strong>Unaligned Data Transfer</strong> 显示了当起始地址的最低有效位（ReqAddr [3:0]）= 0100b 时，传输 4 个 doubleword 的情况。</p><p><a id="图 15">图 15</br><img src=https://icjj.github.io/icer/img/post/sdp/14.png alt></a></p><p>请注意，上述显示的节拍不一定在连续的时钟周期中传输。</p><p>与写请求关联的写数据通过 Originator Data Channel 的 OrigData Field 提供。发起传输的请求呈现在 Originator Request Channel 上。对于对齐的写传输，OrigDataBytEn 信号的使用在 <em><a href="#图 16">图 16</a></em> <strong>Aligned Write Data Transfer with Byte Enables</strong> 中进行了说明。请注意，被屏蔽的字节（OrigDataBytEn[i] = 0）在传输的每个节拍中可能不同。</p><p><a id="图 16">图 16</br><img src=https://icjj.github.io/icer/img/post/sdp/16.png alt></a></p><p>请注意，上述显示的节拍并不一定在连续的时钟周期中传输。</p><p>在同一个虚拟通道内的 Originator Write Data Channel 上，写数据传输的顺序与 Originator Request Channel 上对应的写请求顺序相同。写请求可以在多个虚拟通道上发出。Field <strong>OrigDataVC</strong> 为每个节拍指定虚拟通道。不同虚拟通道的写数据可能被交织传输。没有要求不同虚拟通道的写数据在 Originator Write Data Channel 上出现的顺序与它们在 Originator Request Channel 上请求的顺序相同。</p><p>当实现了这些通道的多个实例时，它们在每个 Originator Write Data Channel 实现上的呈现顺序必须与它们在 Originator Request Channel 上的呈现顺序匹配，原始请求通道 A 被认为在 Originator 请求通道 B 之前，Originator 数据通道 A 被认为在 Originator 数据通道 B 之前。只要数据以相同的逻辑顺序出现，就不要求匹配通道实例——例如，来自 Originator 请求通道 B 上请求的数据可能出现在 Originator 写数据通道 A 上。然而，在同一个虚拟通道内，写数据必须按照写请求的顺序提供，不能在请求之间交错数据节拍。</p><p>当 Original Data Channel 同时用于写数据和探测响应数据时，探测响应数据（<strong>OrigDataChan=1</strong>）的行为类似于用于写数据的单独虚拟通道（<strong>OrigDataChan=0</strong>）——也就是说，探测响应数据的顺序必须与探测响应本身出现的顺序相匹配，但在写数据和探测响应数据之间可能存在交错和重新排序。这种交错可能是由于发起者实际重新排序引起的，或者可能由于 Probe Response Channel 和 Originator Request Channel 之间的通道延迟导致；使得数据看起来被重新排序。</p><p>在为写请求或探测响应呈现数据时，<strong>OrigDataVld</strong> 可以与对应的写命令或探测响应的 <strong>ReqVld</strong> 或 <strong>PrbRspVld</strong> 同时或在之后断言。不允许在命令或探测响应之前呈现数据。在遵守此要求时，发起者不需要检查 <strong>OrigDataRdy</strong>、<strong>ReqRdy</strong> 或 <strong>PrbRspRdy</strong>。只要按照逻辑顺序呈现，发起者可以在单个虚拟通道上有多个待处理的数据传输和/或用于探测响应的数据传输。</p><p><strong>实现注意：</strong> SDP 端口如果具有时钟跨越边界，其中 <strong>OrigDataRdy</strong>、<strong>ReqRdy</strong> 或 <strong>PrbRspRdy</strong> 由外部时钟跨越模块生成，必须采取措施确保上述跨端口要求。一种可能的方法是为 Originator Request Channel、Originator（Write/Probe）Data Channel 和 Probe Response Channel 使用单个时钟跨越模块。实现 Physical Channel Multiplexing 功能的 SDP 端口作为两个独立的端口运行，共享一个 SDP 端口的物理线。这两个独立通道之间没有交错规则。</p><p>多个独立的读取响应可以在接口上交错传输。每个节拍都包括事务标识（<strong>RdRspTag</strong> 和 <strong>RdRspUnitID</strong> 的组合）。Completer 必须根据发起者的能力限制响应交错的最大数量。此限制为每个发起者以实现特定的方式配置。发起者必须有足够的响应缓冲，能够容纳可能被交错的响应总数。</p><p><strong>实现注意：</strong> SOC-15 Fabric 将 Originator Data Channel 上的交错限制在缓存行边界；也就是说，除非节拍的关联地址跨越缓存行边界，否则两个独立的写入或探测响应的数据不能交错。物理通道复用发生在每个周期的基础上，不受任何限制。</p><p><strong>体系结构注意：</strong> 当端口实现了 variable heads-up delay 功能时，交错限制（如果有）适用于响应子通道的时序。</p><p>对于定长读取命令，<strong>ReqAttr</strong> Field 为传输的第一个和最后一个双字提供字节使能。<strong>ReqAttr[3:0]</strong> 分别为第一个双字的字节 3 到字节 0 提供字节使能，<strong>ReqAttr[7:4]</strong> 为最后一个双字的字节 3 到字节 0 提供字节使能。如果 <strong>ReqAttr[i] = 1</strong>，表示正在请求对应的字节，并将在返回时处理；如果 <strong>ReqAttr[i] = 0</strong>，则将忽略对应字节中的数据。读取一个双字时，使用 <strong>ReqAttr[3:0]</strong> 作为字节使能，忽略 <strong>ReqAttr[7:4]</strong>。</p><p>在读取响应通道上未提供字节使能。对于请求中 <strong>ReqAttr</strong> 中对应字节使能未设置的那些字节位置，发起者必须忽略响应的第一个和最后一个双字中返回的数据。</p><p><strong>RdBlk*</strong> 命令总是对一个缓存行进行操作，因此请求的传输大小必须等于缓存行大小。请求的 <strong>ReqAddr</strong> 提供关键字节的地址。如果可能，应该在响应的其他任何节拍之前传输包含所请求关键字节的节拍。</p><p>当实现了 multiple request address 功能，并且数据传输是针对使用非零 <strong>ReqSubAddr</strong> 的两个独立地址组成的事务时，数据传输与发起者进行单个缓存行大小请求时相同。具体而言，<strong>OrigDataOffset</strong> 和 <strong>RdRspOffset</strong> 的增加不考虑它们是两个独立地址的事实。</p><h5 id=a-id321-byte-enable-compression321-byte-enable-compressiona><a id="3.2.1 Byte Enable Compression">3.2.1 Byte Enable Compression</a></h5><p>当实现 <strong>Byte Enable Compression</strong> 时，通过在 <strong>OrigDataBytEn</strong> 中仅使用一位，并使用 <strong>OrigData</strong> 来传输实际的字节使能内容，发起者数据通道的大小被减小。此特性旨在用于端口引脚受限的 <strong>SDP</strong> 实现。本节描述了在实现 <strong>Byte Enable Compression</strong> 时 <strong>OrigData</strong> 总线的功能。</p><p>如果数据传输的所有字节的字节使能都被断言——即从 <strong>ReqAddr</strong> 到 <strong>ReqAddr+ReqLen</strong> 的所有字节都被写入——或者当 <strong>OrigDataChan=1</strong>（携带完整缓存行的探测响应数据）时，发起者可以选择跳过传输字节使能。要跳过传输字节使能，发起者在整个数据传输期间去断言 <strong>OrigDataBytEn</strong>，并且数据节拍的数量等于字节数除以 <strong>OrigData</strong> 的大小（在数据传输中节拍的数量与未实现 <strong>Byte Enable Compression</strong> 时相同）。</p><p>否则，发起者在 <strong>OrigData</strong> 上传输字节使能。为此，发起者在前几个传输节拍期间断言 <strong>OrigDataBytEn</strong>，并将实际的字节使能放置在 <strong>OrigData</strong> 上。对于所有请求数据（例如写入和原子操作），<strong>OrigData</strong> 上的字节使能位置自然对齐到 <strong>OrigData</strong> 的宽度。例如，如果 <strong>OrigData</strong> 有 16 个字节，那么 <strong>OrigData[0]</strong> 将是 <strong>ReqAddr[5:4,000b]</strong> 的字节使能。对于探测响应数据，<strong>OrigData[0]</strong> 是缓存行的第一个字节。</p><p>如果 <strong>OrigData</strong> 的宽度过小，无法在第一个节拍中传输所有字节使能，则使用额外的节拍按照地址顺序传输剩余的字节使能，并在 <strong>OrigDataBytEn</strong> 被断言的情况下，直到字节使能传输完成。如果 <strong>OrigData</strong> 的宽度大于传输字节使能所需的宽度，则所有其他 <strong>OrigData</strong> 位被保留，应该设置为零。完成字节使能传输后，发起者在以正常方式传输数据节拍时去断言 <strong>OrigDataBytEn</strong>。</p><p>要么不使用任何数据节拍来传输字节使能（对于非稀疏写入或探测数据），要么发送每个传输数据字节的所有字节使能。</p><p>当 <strong>OrigDataBytEn</strong> 被断言时，<strong>OrigDataParity</strong> 提供字节使能的偶校验。</p><h5 id=a-id322-originator-data-compression-322-originator-data-compression-a><a id="3.2.2 Originator Data Compression ">3.2.2 Originator Data Compression</a></h5><p>实现了 Originator Data Compression 功能的 SDP 端口可以发出四个额外的命令：</p><ul><li>VicBlkFullZero</li><li>WrSizedFullZero</li><li>VicBlkFullComp</li><li>WrSizedFullComp</li></ul><p>VicBlkFullZero 和 WrSizedFullZero 在 ReqLen 中设置适当的写入长度，但不传输任何数据。Completer 的行为就好像数据节拍已使用全零数据传输，所有字节使能设置（与 ReqAddr/ReqLen 一致），并且 OrigDataError=0。</p><p>VicBlkFullComp 和 WrSizedFullComp 在 ReqLen 中设置适当的写入长度，但可能传输较少的数据节拍。实际的数据节拍数量在 ReqAttr[7:6] 中指定。基于 ReqLen，由于命令的对齐性质，任何必须为零的地址位携带压缩类型的信息。例如，如果 ReqLen=0xF，则该命令必须是一个对齐的 64 字节地址，因此 ReqAddr[5:2] 携带压缩类型。此压缩类型的编码超出了本文档的范围。</p><p>VicBlkFull 的所有其他要求适用于 VicBlkFullZero 和 VicBlkFullComp。WrSizedFull 的所有其他要求适用于 WrSizedFullZero 和 WrSizedFullComp。</p><h5 id=a-id323-metadata-compression323-metadata-compressiona><a id="3.2.3 MetaData Compression">3.2.3 MetaData Compression</a></h5><p>实现 Metadata Compression 功能的 SDP 端口会在数据中添加一个额外的扩展——“metadata”，它指示数据是否被压缩以及如何解压数据。</p><p>从高层次来看，metadata 可以被视为压缩方法或数据的直接映射中的“字典索引”。只有同时拥有 metadata 和数据字节，才能重建未压缩的数据部分。metadata 的实际大小和编码以及字典方法超出了本规范的范围，但对于整个 SOC 必须是通用的。然而，规范要求，如果 metadata 全为 1（例如，如果 metadata 是 8 位，FFh），则表示数据未被压缩。Completer 用于存储 metadata 和查找 metadata 的方法也超出了本规范的范围。作为一个使用 8 位 metadata Field 的假设示例，metadata 值为 01h（使用第九位实现偶校验）可能表示数据块的每个字节都等于单个十六进制值。该值可能位于传输数据字节的字节 0（OrigData[7:0]）中。如果 OrigData[7:0] 是 55h，那么未压缩的数据块就是整个块的重复 55555555h&mldr;.。为了恢复此数据，只需要存储两个字节——metadata（01h）和重复数据的值（55h）。</p><p>并非 SOC 中的每个 SDP Port 实现都必须实现 Metadata Compression 功能。当存在混合的 SDP 实现时，一个不实现 Metadata Compression 功能的端口（在本段中称为仅支持未压缩数据的端口）正在读取或写入数据时，读取响应中的数据总是未压缩的。当一个端口在没有实现 ReqCompMode 和 ReqSpecDataFetch 的情况下请求数据时，Completer 是否绕过 metadata 的查找取决于系统。如果 Completer 绕过查找，硬件和/或软件必须提供一种方法（也超出了本规范的范围），以确保在任何仅需要未压缩数据的 SDP Port 访问之前，数据是未压缩的。使用 ReqCompMode=11b 的 WrNoDataNC 可以在使用 Metadata Bypass 访问数据之前解压任何数据。SDP Port 在当前未压缩的数据上使用 WrNoDataNC 是合法的。使用 ReqCompMode=00b（bypass）也要求硬件和/或软件知道数据必须未压缩。Completer 没有要求进行一致性检查来检测当数据实际上被压缩时绕过 metadata 查找的读取和/或写入，必须特别小心以防止读取或写入不正确的数据。允许 Metadata Bypass 的实现可能需要软件清除数据块，以避免恶意行为者在压缩数据上绕过 metadata 导致的安全泄漏。这超出了本规范的范围。</p><p>在写入压缩数据时，要求等效的未压缩数据块是固定大小的。当前的 SDP 规范要求未压缩块为 128B 或 256B（压缩工作在 128B 或 256B 块上），并且地址必须对齐到块大小。因此，启用压缩的写入会更新一个对齐的固定大小块，因此可以假定字节使能全部为 1。OrigDataBytEn Field 被用于携带 metadata。当为此压缩传输传输多个数据节拍时，OrigDataBytEn 在所有节拍上重复。将 OrigDataBytEn 作为 metadata 的使用由命令（除 WrSizedFullComp 外的 WrSized*）以及当 ReqAttr[7:6] != 00b 时指定。所有其他命令（包括所有原子操作），或者当 ReqAttr[7:6] = 00b 时，OrigData* 上的数据未压缩，OrigDataBytEn Field 按 SDP 中数据传输的正常方式解释。压缩数据仍然根据其在压缩块中占据的顺序，从 0 到 n-1（其中 n 是实际传输的节拍数）分配连续的 OrigDataOffset 值。任何提供按地址顺序数据的要求也适用于压缩数据。</p><p>在读取压缩数据时，Originator 可以请求数据以压缩或未压缩形式返回。当请求数据以压缩形式返回时，压缩算法可能无法压缩当前数据块的内容——metadata 字典不可能包含所有任意的数据模式——因此 RdRspDataCompMeta 指定块的实际压缩状态（全 1 表示数据未压缩）。原子操作和不支持 Metadata Compression 的命令返回的数据以未压缩编码返回。当绕过 metadata 时，返回的 metadata 也表示数据块未压缩（全 1）。</p><p>在 Originator Data Channel 上传输压缩数据时，ReqLen 指示压缩数据的大小。ReqAttr[7:6] 将指示未压缩的大小。当在读取时返回压缩数据，指定的 ReqLen 假定数据块未压缩，因此它是请求的数据块的大小。返回的数据节拍数可能因压缩数据的实际大小而较小。RdRspLast Field 指示返回的压缩数据的实际大小。压缩数据仍然根据其在压缩块中占据的顺序，从 0 到 n-1（其中 n 是实际传输的节拍数）分配连续的 RdRspDataOffset 值。任何提供按地址顺序数据的要求也适用于压缩数据。</p><p>某些字典可能能够将固定的数据模式完全压缩到 metadata 本身中（例如，全零可能用唯一的 metadata 编码表示）。在这种情况下，仍然需要传输一个数据节拍，即使只是为了传输 metadata。建议任何未使用的字节被“围栏”，并以全零或全一提供，以避免未初始化数据的潜在安全泄漏，但 Completer 可以跳过实际数据块的访问以节省带宽。例如，实际内存可能未被写入，只有 metadata 被更新。数据奇偶校验仍然保持偶校验，无论是否需要字节来重建未压缩的数据块。此外，即使 OrigData 或 RdRspData 在重建未压缩的数据块时不是必需的，数据信用处理仍然对这个单个数据节拍正常运行。</p><p>具有数据传输的 Victims 和探测响应必须始终提供未压缩数据，因为 ReqAttr 和 ReqCompMode 没有方法指示 Victim 和探测响应数据的压缩状态。当 SDP Port 使用 WrNoDataNC 来解压数据时，任何系统缓存不一定被失效。</p><p>一个 256B 数据块的两半可以根据 metadata 值独立压缩。Completer 也可以压缩一个 256B 数据块，或者在 ReqCompMode 不要求禁用 Completer 压缩的情况下，将两个 128B 数据块的压缩合并。</p><h5 id=a-id324-read-response-with-nodata324-read-response-with-nodataa><a id="3.2.4 Read Response with NODATA">3.2.4 Read Response with NODATA</a></h5><p>&ldquo;RdRspDataStatus&rdquo; 为 <strong>NODATA</strong> 仅在以下情况下允许：</p><p>1）当总线上有空闲周期时（即 <strong>RdRspVld</strong> 未断言，或者如果实现了 Heads-up 功能，则 <strong>RdRspDataVld</strong> 未断言）。然而，当总线上有空闲周期时，<strong>Originators</strong> 必须忽略 <strong>RdRspDataStatus</strong> 的内容。</p><p>2）<strong>Completer</strong> 先前已使用 <strong>EARLY</strong> 状态（和数据）响应了事务，现在正在完成事务，同时指示先前提供的数据是有效数据。</p><p>3）<strong>Completer</strong> 可以使用 <strong>RdRspStatus=OKAY_NODATA</strong> 和 <strong>RdRspDataStatus=NODATA</strong> 作为对 <strong>ChgToX</strong> 事务的响应。</p><p>4）<strong>Completer</strong> 使用 <strong>RdRspStatus=OKAY_NODATA</strong> 和 <strong>RdRspDataStatus=NODATA</strong> 作为对 <strong>ChgToXNR</strong> 和 <strong>ValBlk</strong> 事务的响应。</p><p>5）<strong>Completer</strong> 可以对已被取消的事务以读取响应进行响应，使用 <strong>RdRspStatus=OKAY</strong> 或 <strong>OKAY_NODATA</strong>，且 <strong>RdRspDataStatus=NODATA</strong>。如果事务实际上被取消，则会发生这种编码。如果取消未执行，事务正常完成。</p><p>6）<strong>Completer</strong> 可以对指示为存储探测重取的 <strong>RdBlkL</strong>（<strong>ReqAttr[1:0] = 10b</strong>）使用 <strong>RdRspStatus=OKAY_NODATA</strong> 和 <strong>RdRspDataStatus=NODATA</strong> 进行响应。不提供存储探测获取数据的原因超出了本规范的范围。</p><p>7）<strong>Completer</strong> 对任何未经请求的 <strong>SYSFATALERR</strong> 响应使用 <strong>RdRspDataStatus</strong> 为 <strong>NODATA</strong>。</p><p>8）<strong>Originator</strong> 使用了某些不需要数据响应的 <strong>SpecPrefCmd</strong> 编码。</p><p>在其他情况下，当事务在非错误情况下会返回数据时，在错误情况下（例如，当 <strong>RdRspStatus</strong> 为 <strong>DECERR</strong>、<strong>SLVERR</strong>、<strong>TRANSERR</strong> 或 <strong>PROTVIOL</strong>）提供 <strong>RdRspDataStatus</strong> 为 <strong>NODATA</strong> 是不合法的。建议 <strong>Completer</strong> 对 <strong>ChgToX</strong> 事务的错误响应使用 <strong>NODATA</strong>。提供 <strong>RdRspStatus</strong> 为 <strong>OKAY_NODATA</strong> 且提供非 <strong>NODATA</strong> 的 <strong>RdRspDataStatus</strong> 也是不合法的。</p><p>带有 <strong>NODATA</strong> 的响应总是单个节拍（<strong>RdRspLast</strong> 被断言）。</p><h5 id=a-id325-read-response-and-data-associated-with-error-status325-read-response-and-data-associated-with-error-statusa><a id="3.2.5 Read Response and Data Associated with Error Status">3.2.5 Read Response and Data Associated with Error Status</a></h5><p>如果 <strong>RdRspStatus</strong> 表示错误（SLVERR、DECERR、PROTVIOL、TRANSERR、CMPTO 或 CRS），<strong>Completer</strong> 必须传输所有请求的数据节拍，包括断言 <strong>RdRspLast</strong>；如果由于错误没有可用数据，则使用制造的数据。建议使用全一的制造数据模式。</p><p>对于可缓存的事务，<strong>Originator</strong> 不得缓存返回的数据。通常，任何以 <strong>RdRspStatus</strong> 或 <strong>WrRspStatus</strong> 表示错误完成的事务都不会改变该行的缓存状态。</p><h5 id=a-id326-read-response-data-retransmission326-read-response-data-retransmissiona><a id="3.2.6 Read Response Data Retransmission">3.2.6 Read Response Data Retransmission</a></h5><p>如果在某个节拍上 <strong>RdRspDataStatus</strong> 是 <strong>RETRANSMIT</strong>，则数据传输必须完成，直到断言 <strong>RdRspLast</strong> 的节拍为止。一旦 <strong>RETRANSMIT</strong> 被断言，与 <strong>RETRANSMIT</strong> 同时的那个数据节拍以及该响应的所有后续节拍，必须由 Originator 保留，但在接收到最后一个节拍之前不得消耗或转发。</p><p>当在最后一个节拍上断言了 <strong>RETRANSMIT</strong> 时，Originator 必须丢弃任何已保留但未消耗或转发的节拍。在数据重新传输之前，Originator 不得发送响应确认（如果在此响应中使用了）。Completer 随后将重新传输整个响应序列，包括任何先前的节拍，而不依赖于 <strong>Probe Request Channel</strong>。在 <strong>RETRANSMIT</strong> 状态和实际的重新传输之间，Completer 可以交错其他事务响应。</p><p>在重新传输事件期间，Originator 必须跟踪哪些数据节拍（如果有的话）已被消耗或转发。Completer 允许在此重新传输事件期间发出任何有效的 <strong>RETRANSMIT</strong>、<strong>VALID</strong> 或 <strong>DATERR</strong> 的组合。Completer 必须提供一种方法来限制重新传输的次数以避免活锁，但 Originator 不得有任何限制。</p><p>当在除最后一个节拍之外的某个节拍上断言了 <strong>RETRANSMIT</strong>，且在最后一个节拍上未断言 <strong>RETRANSMIT</strong>，则最后一个节拍的 <strong>RdRspDataStatus</strong> 编码适用于所有已断言 <strong>RETRANSMIT</strong> 的节拍。</p><p><em><a href="#表 37">表 37</a></em> <strong>Read Response Data Retransmission Possibilities</strong> 显示了跨越两个数据节拍的响应的所有可能性。</p><p><strong><a id="表 37">表 37</a> 读取响应数据重新传输的可能性</strong></p><table><thead><tr><th>每个节拍的 RdRspDataStatus</th><th>含义</th></tr></thead><tbody><tr><td>VALID, VALID</td><td>两个节拍都是有效的，可以被消耗。</td></tr><tr><td>VALID, DATERR</td><td>第二个节拍包含未校正的数据错误。</td></tr><tr><td>DATERR, VALID</td><td>第一个节拍包含未校正的数据错误。</td></tr><tr><td>DATERR, DATERR</td><td>两个节拍都有未校正的数据错误。</td></tr><tr><td>DATERR, RETRANSMIT</td><td>第一个节拍包含未校正的数据错误。Completer 将在稍后重新传输整个响应，包括第一个节拍。在重新传输时，无法预测第一个节拍是否仍有未校正的数据错误，或者数据错误是否无法重现。</td></tr><tr><td>VALID, RETRANSMIT</td><td>第一个节拍是有效的，可以被消耗。Completer 将在稍后重新传输整个响应，包括第一个节拍。</td></tr><tr><td>RETRANSMIT, VALID</td><td>两个节拍都是有效的，可以被消耗。</td></tr><tr><td>RETRANSMIT, DATERR</td><td>两个节拍都有未校正的数据错误。</td></tr><tr><td>RETRANSMIT, RETRANSMIT</td><td>两个节拍都不能被消耗。Completer 将在稍后重新传输响应。</td></tr></tbody></table><p>您可以将上述内容复制粘贴到微软 Word 中，格式将保持不变。
<em><a href="#表 37">表 37</a></em> <strong>Read Response Data Retransmission Possibilities</strong> 显示了跨越两个数据节拍的响应的所有可能性。</p><h5 id=a-id327-read-response-data-lag-and-the-variable-heads-up-feature-327-read-response-data-lag-and-the-variable-heads-up-feature-a><a id="3.2.7 Read Response Data Lag and the Variable Heads-Up Feature ">3.2.7 Read Response Data Lag and the Variable Heads-Up Feature</a></h5><hr><ul class=pager><li class=previous><a href=/icer/post/spi-%E5%8D%8F%E8%AE%AE%E4%BB%8B%E7%BB%8D/ data-toggle=tooltip data-placement=top title="SPI 介绍">&larr;
Previous Post</a></li><li class=next><a href=/icer/post/pcie6.2-%E5%8D%8F%E8%AE%AE%E7%BF%BB%E8%AF%91/ data-toggle=tooltip data-placement=top title=PCIE6.2-协议翻译>Next
Post &rarr;</a></li></ul><script src=https://giscus.app/client.js data-repo=ICJJ/icer data-repo-id=R_kgDOMWEQRg data-category=General data-category-id=DIC_kwDOMWEQRs4CgyrH data-mapping=pathname data-reactions-enabled=1 data-emit-metadata=0 data-theme=light data-lang=en crossorigin=anonymous async></script></div><div class="col-lg-2 col-lg-offset-0
visible-lg-block
sidebar-container
catalog-container"><div class=side-catalog><hr class="hidden-sm hidden-xs"><h5><a class=catalog-toggle href=#>CATALOG</a></h5><ul class=catalog-body></ul></div></div><div class="col-lg-8 col-lg-offset-2
col-md-10 col-md-offset-1
sidebar-container"><section><hr class="hidden-sm hidden-xs"><h5><a href=/tags/>FEATURED TAGS</a></h5><div class=tags><a href=/icer/tags/ahb title=ahb>ahb
</a><a href=/icer/tags/amba title=amba>amba
</a><a href=/icer/tags/amba5 title=amba5>amba5
</a><a href=/icer/tags/apb title=apb>apb
</a><a href=/icer/tags/axi title=axi>axi
</a><a href=/icer/tags/blog title=blog>blog
</a><a href=/icer/tags/bus title=bus>bus
</a><a href=/icer/tags/cache title=cache>cache
</a><a href=/icer/tags/ddr title=ddr>ddr
</a><a href=/icer/tags/flash title=flash>flash
</a><a href=/icer/tags/git title=git>git
</a><a href=/icer/tags/html title=html>html
</a><a href=/icer/tags/i2c title=i2c>i2c
</a><a href=/icer/tags/ic%E9%AA%8C%E8%AF%81 title=ic验证>ic验证
</a><a href=/icer/tags/multi-layer-ahb title=multi-layer-ahb>multi-layer-ahb
</a><a href=/icer/tags/nxp title=nxp>nxp
</a><a href=/icer/tags/pcie title=pcie>pcie
</a><a href=/icer/tags/ram title=ram>ram
</a><a href=/icer/tags/sdp title=sdp>sdp
</a><a href=/icer/tags/spi title=spi>spi
</a><a href=/icer/tags/uart title=uart>uart
</a><a href=/icer/tags/uvm title=uvm>uvm
</a><a href=/icer/tags/uvm%E5%AE%9E%E6%88%98 title=uvm实战>uvm实战
</a><a href=/icer/tags/%E4%B8%B2%E5%8F%A3 title=串口>串口
</a><a href=/icer/tags/%E5%8D%8F%E8%AE%AE%E7%BF%BB%E8%AF%91 title=协议翻译>协议翻译
</a><a href=/icer/tags/%E5%A4%A7%E5%B0%8F%E7%AB%AF title=大小端>大小端
</a><a href=/icer/tags/%E5%AD%97%E8%8A%82%E5%BA%8F title=字节序>字节序
</a><a href=/icer/tags/%E7%9F%A5%E8%AF%86%E6%8F%90%E7%BA%B2 title=知识提纲>知识提纲
</a><a href=/icer/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0 title=读书笔记>读书笔记</a></div></section><section><hr><h5>FRIENDS</h5><ul class=list-inline><li><a target=_blank href=https://zhaozhihan.com>Linda的博客</a></li></ul></section></div></div></div></article><footer><div class=container><div class=row><div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1"><ul class="list-inline text-center"><li><a href=mailto:chengjj9527@gmail.com><span class="fa-stack fa-lg"><i class="fas fa-circle fa-stack-2x"></i>
<i class="fas fa-envelope fa-stack-1x fa-inverse"></i></span></a></li><li><a target=_blank href=https://github.com/icjj><span class="fa-stack fa-lg"><i class="fas fa-circle fa-stack-2x"></i>
<i class="fab fa-github fa-stack-1x fa-inverse"></i></span></a></li><li><a target=_blank href=https://github.com/ICJJ><span class="fa-stack fa-lg"><i class="fas fa-circle fa-stack-2x"></i>
<i class="fab fa-gitlab fa-stack-1x fa-inverse"></i></span></a></li><li><a target=_blank href=https://stackoverflow.com/users/26381389><span class="fa-stack fa-lg"><i class="fas fa-circle fa-stack-2x"></i>
<i class="fab fa-stack-overflow fa-stack-1x fa-inverse"></i></span></a></li><li><a href rel=alternate type=application/rss+xml title="ICJJ Blog"><span class="fa-stack fa-lg"><i class="fas fa-circle fa-stack-2x"></i>
<i class="fas fa-rss fa-stack-1x fa-inverse"></i></span></a></li></ul><p class="copyright text-muted">Copyright &copy; ICJJ Blog 2024<br><a href=https://themes.gohugo.io/hugo-theme-cleanwhite>CleanWhite Hugo Theme</a> by <a href=https://zhaohuabing.com>Huabing</a> |
<iframe style=margin-left:2px;margin-bottom:-5px frameborder=0 scrolling=0 width=100px height=20px src="https://ghbtns.com/github-btn.html?user=zhaohuabing&repo=hugo-theme-cleanwhite&type=star&count=true"></iframe></p></div></div></div></footer><script>function loadAsync(e,t){var s=document,o="script",n=s.createElement(o),i=s.getElementsByTagName(o)[0];n.src=e,t&&n.addEventListener("load",function(e){t(null,e)},!1),i.parentNode.insertBefore(n,i)}</script><script>$("#tag_cloud").length!==0&&loadAsync("/js/jquery.tagcloud.js",function(){$.fn.tagcloud.defaults={color:{start:"#bbbbee",end:"#0085a1"}},$("#tag_cloud a").tagcloud()})</script><script>loadAsync("https://cdn.jsdelivr.net/npm/fastclick@1.0.6/lib/fastclick.min.js",function(){var e=document.querySelector("nav");e&&FastClick.attach(e)})</script><script type=text/javascript>function generateCatalog(e){_containerSelector="div.post-container";var t,n,s,o,i,a=$(_containerSelector),r=a.find("h1,h2,h3,h4,h5,h6");return $(e).html(""),r.each(function(){t=$(this).prop("tagName").toLowerCase(),o="#"+$(this).prop("id"),n=$(this).text(),i=$('<a href="'+o+'" rel="nofollow">'+n+"</a>"),s=$('<li class="'+t+'_nav"></li>').append(i),$(e).append(s)}),!0}generateCatalog(".catalog-body"),$(".catalog-toggle").click(function(e){e.preventDefault(),$(".side-catalog").toggleClass("fold")}),loadAsync("/icer/js/jquery.nav.js",function(){$(".catalog-body").onePageNav({currentClass:"active",changeHash:!1,easing:"swing",filter:"",scrollSpeed:700,scrollOffset:0,scrollThreshold:.2,begin:null,end:null,scrollChange:null,padding:80})})</script><script src=https://cdn.jsdelivr.net/gh/jmnote/plantuml-encoder@1.2.4/dist/plantuml-encoder.min.js integrity="sha256-Qsk2KRBCN5qVZX7B+8+2IvQl1Aqc723qV1tBCQaVoqo=" crossorigin=anonymous></script><script>(function(){let e="language-plantuml";Array.prototype.forEach.call(document.querySelectorAll("[class^="+e+"]"),function(e){let t=document.createElement("IMG");t.loading="lazy",t.src="http://www.plantuml.com/plantuml/svg/~1"+plantumlEncoder.encode(e.innerText),e.parentNode.parentNode.insertBefore(t,e.parentNode),e.parentNode.style.display="none"})})()</script></body></html>